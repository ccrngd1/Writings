{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}{\f1\fmodern\fcharset0\fprq2 CourierNewPS-BoldMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \fi360\ltrch\loch {\field{\*\fldinst HYPERLINK "scrivlnk://A3D41ADE-88D8-4401-9FD5-007B8C7E4FBE"}{\fldrslt\f0\fs24\b0\i0 YellowPaper}}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Ethereum aims to build the generalized technology which all transaction based state machine concepts may be built. Further aims to provide end-developers a tightly integrated end-to-end system for build software on a trustful object message compute framework.}
\par\plain {\f0\fs24\b0\i0 This credo clearly denotes the intentional focus on smart contracts and not on a specific cryptocurrency implementation, such as Ether.}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs36\b1\i0 Blockchain Paradigm}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 Ethereum can be viewed as a transaction-based state machine}
\par\plain {\f0\fs24\b0\i0 Beginning with a genesis state and incrementally execute transactions to morph into some final state. (This final state is known as the canonical \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93version\u8221\'94 of the world)}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 A state can include account balance, reputations, trust arrangements, data about the physical world. Transactions thus represent a valid arc between two states - vital being the the important part - there exist many more invalid than valid state changes. Invalid state changes could be thins such as reducing an account without increasing another account.}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Transactions are turned into blocks, which are chained together using cryptographic hashes. Blocks function as a journal, recording a series of transactions together with the previous block and an identifier for the final state (but do not store the final state itself).}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs24\b1\i0 History}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 Since the system is decentralized, all parties have an opportunity to create a new block on some older, pre-existing block. If two or more parties submit new blockchains, a fork occurs, where nodes in the system will have differing version of the chain, potentially building more blocks on top of it. In order to form a consensus as to which resulting chain is correct, there must be a method to determine the correct chain, this is the GHOST protocol. }
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs36\b1\i0 Conventions}
\par\pard\plain \fi360\ltrch\loch \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 - \loch\af0\hich\af0\dbch\af0\uc1\u963\'73 - small sigma - world state}
\par\plain {\f0\fs24\b0\i0 - \loch\af0\hich\af0\dbch\af0\uc1\u181\'B5 - small mu - machine state}
\par\plain {\f0\fs24\b0\i0 - \loch\af0\hich\af0\dbch\af0\uc1\u933\'3F - big upsilon - ethereum state transition function}
\par\plain {\f0\fs24\b0\i0 - C - big \loch\af0\hich\af0\dbch\af0\uc1\u8216\'91c\u8217\'92 - general cost function (ie Csstore - cost for SSTORE operation)}
\par\plain {\f0\fs24\b0\i0 - T - big \loch\af0\hich\af0\dbch\af0\uc1\u8216\'91t\u8217\'92 - denote Ethereum transaction (ie - Tn - denotes nonce of a said transaction)}
\par\plain {\f0\fs24\b0\i0 - n - small \loch\af0\hich\af0\dbch\af0\uc1\u8216\'91n\u8217\'92 - denotes nonce }
\par\plain {\f0\fs24\b0\i0 - \loch\af0\hich\af0\dbch\af0\uc1\u948\'64- small sigma - denotes number of items required on stack for given operation}
\par\plain {\f0\fs24\b0\i0 - [ ] - denotes index into an array (ie \loch\af0\hich\af0\dbch\af0\uc1\u181\'B5[0] means machine state 0, \u963\'73[0] means account 0)}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs36\b1\i0 Blocks, state, and transactions}
\par\plain {\f1\fs24\b1\i0 World State}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 World state is a mapping between address (160bit identifiers) and account states (a data structure serialized by RLP).}
\par\plain {\f0\fs24\b0\i0 Not stored on the blockchain, but is implemented as modified Merkle Patricia tree (MMP trie).}
\par\plain {\f0\fs24\b0\i0 The trie requires a simple database backend that maintains a mapping of byte arrays to byte arrays - we name this underlying database the state database.}
\par\plain {\f0\fs24\b0\i0 This is an immutable data structure, which allows any previous state to be recalled simply by altering the root hash (root hashes are all stored on blockchain)}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Account state (\loch\af0\hich\af0\dbch\af0\uc1\u963\'73[a]) consists of:}
\par\plain {\f0\fs24\b0\i0 -nonce - scalar value equal to number of transaction sent from this address (or number of contract-creations made by this account) - \loch\af0\hich\af0\dbch\af0\uc1\u963\'73[a]n}
\par\plain {\f0\fs24\b0\i0 -balance - scalar value equal to number of Wei owned by address - \loch\af0\hich\af0\dbch\af0\uc1\u963\'73[a]b}
\par\plain {\f0\fs24\b0\i0 -storageRoot - a 256bit hash of the root node of a MPtrie that encodes the storage contents of the account -\loch\af0\hich\af0\dbch\af0\uc1\u963\'73[a]s}
\par\plain {\f0\fs24\b0\i0 -codeHash - hash of the EVM code of this account - this is the code that gets executed should this address receive a message call; it is immutable and thus can not be changed after construction. All code fragments are contained in the state database under their corresponding hashes for later retrieval. - \loch\af0\hich\af0\dbch\af0\uc1\u963\'73[a]c and thus the code may be denoted as b => KEC(b) = \u963\'73[a]c}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 An account is empty when it has no code, zero nonce, and zero balance.}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs24\b1\i0 The transaction}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 A transaction - T - is a single cryptographically-signed instruction constructed by an actor external of Ethereum.}
\par\plain {\f0\fs24\b0\i0 There are two types of transactions:}
\par\plain {\f0\fs24\b0\i0 -those that result in a message call}
\par\plain {\f0\fs24\b0\i0 -those that result in creation of a new account with associated code (contract creation)}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Transaction consists of}
\par\plain {\f0\fs24\b0\i0 -none - scalar value equal to the number of transactions sent by sender - Tn}
\par\plain {\f0\fs24\b0\i0 -gasPrice - scalar value equal to the number of Wei to be paid per unit of gas for all computation costs incurred as a result of the execution of this transaction - Tp}
\par\plain {\f0\fs24\b0\i0 -gasLimit - scalar value equal to the max amount of gas that should be used in executing this transaction. This is paid up-front before any computation is done and my not be increased later (but unused portions may be refunded) - Tg}
\par\plain {\f0\fs24\b0\i0 -to - the 160 address of the message calls recipient (or for contract creation 0 - Tt}
\par\plain {\f0\fs24\b0\i0 -value - scalar value equal to the number of Wei to be transferred to the message calls recipient (or in contract creation, an endowment to the newly created account) - Tv}
\par\plain {\f0\fs24\b0\i0 -v,r,s - values corresponding to the signature of the transaction used to determine the sender of the transaction - Tw, Tr, Ts}
\par\plain {\f0\fs24\b0\i0 -init - (only for contract creations) unlimited size byte array specifying the EVM-code for the account initialization procedure - Ti}
\par\plain {\f0\fs24\b0\i0 -data - (only message call) an unlimited size byte array specifying the input data of the message call - Td}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 \{\\Scrv_ps=function toHex(str) \{\\end_Scrv_ps\}}
\par\plain {\f0\fs24\b0\i0 \{\\Scrv_ps= var hex = ''\\end_Scrv_ps\}}
\par\plain {\f0\fs24\b0\i0 \{\\Scrv_ps= for(var i=0;i<str.length;i++) \{\\end_Scrv_ps\}}
\par\plain {\f0\fs24\b0\i0 \{\\Scrv_ps=  hex += ''+str.charCodeAt(i).toString(16)\\end_Scrv_ps\}}
\par\plain {\f0\fs24\b0\i0 \{\\Scrv_ps= \}\\end_Scrv_ps\}}
\par\plain {\f0\fs24\b0\i0 \{\\Scrv_ps= return hex\\end_Scrv_ps\}}
\par\plain {\f0\fs24\b0\i0 \{\\Scrv_ps=\}\\end_Scrv_ps\}}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 \{\\Scrv_ps=let addr = web3.eth.accounts[0]\\end_Scrv_ps\}}
\par\plain {\f0\fs24\b0\i0 \{\\Scrv_ps=let msg = 'I really did make this message'\\end_Scrv_ps\}}
\par\plain {\f0\fs24\b0\i0 \{\\Scrv_ps=let signature = web3.eth.sign(addr, '0x' + toHex(msg))\\end_Scrv_ps\}}
\par\plain {\f0\fs24\b0\i0 \{\\Scrv_ps=signature = signature.substr(2); //remove 0x\\end_Scrv_ps\}}
\par\plain {\f0\fs24\b0\i0 \{\\Scrv_ps=const r = '0x' + signature.slice(0, 64)\\end_Scrv_ps\}}
\par\plain {\f0\fs24\b0\i0 \{\\Scrv_ps=const s = '0x' + signature.slice(64, 128)\\end_Scrv_ps\}}
\par\plain {\f0\fs24\b0\i0 \{\\Scrv_ps=const v = '0x' + signature.slice(128, 130)\\end_Scrv_ps\}}
\par\plain {\f0\fs24\b0\i0 \{\\Scrv_ps=const v_decimal = web3.toDecimal(v)\\end_Scrv_ps\}}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs24\b1\i0 The block}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 The block is the collection of relevant pieces of information (block header - H) together with information corresponding to the comprised transactions (}{\f1\fs24\b1\i0 T}{\f0\fs24\b0\i0 ) and a set of other block headers (}{\f1\fs24\b1\i0 U}{\f0\fs24\b0\i0 ) that are known to have parent equal to the present blocks parents parent (ommers/uncles)}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 The block header contains several pieces of information}
\par\plain {\f0\fs24\b0\i0 -parentHash - Keccak 256 bit hash of the parent blocks header - Hp}
\par\plain {\f0\fs24\b0\i0 -ommersHash - Keccak 256 bit hash of the ommers list portion of this block - Ho}
\par\plain {\f0\fs24\b0\i0 -beneficiary - the 160 bit address to which all fess are collected from the successful mining of this block - Hc}
\par\plain {\f0\fs24\b0\i0 -stateRoot - Keccak 256 bit hash of the root node of the state trie, after all transactions are executed and finalizations applied - Hr}
\par\plain {\f0\fs24\b0\i0 -transactionsRoot - Keccak 256 bit hash of the root node of the trie structure populated with each transaction in the transaction list portion of the block - Ht}
\par\plain {\f0\fs24\b0\i0 -receiptsRoot - Keccak 256 bit hash of the root node of the trie structure populated with the receipts of each transaction in the transactions list portion of the block - He}
\par\plain {\f0\fs24\b0\i0 -logsBloom - bloom filter composed of indexable information (logger address and log topics) contained in each log entry form the receipt of each transaction in the transaction list - Hb}
\par\plain {\f0\fs24\b0\i0 -difficulty - scalar value corresponding to the difficulty level of this block. This can be calculated from the previous blocks difficulty level and the timestamp - Hd}
\par\plain {\f0\fs24\b0\i0 -number - scalar value equal to the number of ancestor blocks. The genesis block = 0. - Hi}
\par\plain {\f0\fs24\b0\i0 -gasLimit - scalar value equal to the current limit of gas expenditure per bock - Hl}
\par\plain {\f0\fs24\b0\i0 -gasUsed - scalar value equal to the total gas used in transaction in this block - Hg}
\par\plain {\f0\fs24\b0\i0 -timestamp - scalar value equal to the reasonable output of unix time() at blocks inception - Hs}
\par\plain {\f0\fs24\b0\i0 -extraData - arbitrary byte array containing data relevant to this block.  Must be 32 bytes or fewer - Hx}
\par\plain {\f0\fs24\b0\i0 -mixHash - 256 bit hash which, combined with nonce, proves that a sufficient amount of computation has be carried out on this block - Hm}
\par\plain {\f0\fs24\b0\i0 -none - 64 bit value which, combined with the mixhash, proves that a sufficient amount of computation has been carried out on this block - Hn}
\par\plain {\f0\fs24\b0\i0 -list of ommer block headers - Bu}
\par\plain {\f0\fs24\b0\i0 -list of transaction - BsubT}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Transaction Receipt}
\par\plain {\f0\fs24\b0\i0 Each receipt (BsubR[i] for the ith transaction) is placed in an index-keyed trie and the root recroded in the header (as He)}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 The receipt (R) is a tuple of 4 items.}
\par\plain {\f0\fs24\b0\i0 Consisting of}
\par\plain {\f0\fs24\b0\i0 -cumulative gas used in the block containing the transaction receipt as of immediately after the transaction has happened - Ru}
\par\plain {\f0\fs24\b0\i0 -the set of logs created through execution of the transaction - Rl}
\par\plain {\f0\fs24\b0\i0 -bloom filter composed from information in these logs - Rb}
\par\plain {\f0\fs24\b0\i0 -status code of the transaction - Rz}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs36\b1\i0 Gas and payment}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 In order to avoid issues of network abuse and sidestep the inevitable questions stemming from Turing completeness (the halting problem), all programmable computation in Ethereum is subject to fees.  The fee schedule is specified in units of gas. Thus any given fragment of programmable computation (creating contracts, making message calls, utilising and accessinga ccount storage, executing operations on the EVM) has a universally a\{\\Scrv_fn=}{\f0\fs24\b0\i0 greed\\end_Scrv_fn\}}{\f0\fs24\b0\i0  cost in terms of gas.}
\par\plain {\f0\fs24\b0\i0 Every transaction has a gasLimit - amount of gas which is implicitly purchased from the senders account balance, at the gasPrice as defined in that transaction. Any unused gas after transaction completes is returned.}
\par\plain {\f0\fs24\b0\i0 Ether used as gas is given to the beneficiary (miner). Senders can set any gasPrice they wish, but miners are free to only include transactions with a high gasPrice.}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs36\b1\i0 Transaction Execution}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 Execution of transaction is most complex part of the Ethereum protocol.  It defines the state transition (\loch\af0\hich\af0\dbch\af0\uc1\u933\'3F).}
\par\plain {\f0\fs24\b0\i0 A transaction must meet the following criteria}
\par\plain {\f0\fs24\b0\i0 1) transaction is well formed RLP, with no additional trailing bytes}
\par\plain {\f0\fs24\b0\i0 2) transaction signature is valid}
\par\plain {\f0\fs24\b0\i0 3) transaction nonce is valid (equivalent to the sender accounts current nonce)}
\par\plain {\f0\fs24\b0\i0 4) gas limit is no smaller than the intrinsic gas used by the transaction}
\par\plain {\f0\fs24\b0\i0 5) sender account balance contains at least the cost required in up front payment}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs24\b1\i0 Substate}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 Throughout transaction execution, we accrue certain information that is acted upon immediately following the transaction.}
\par\plain {\f0\fs24\b0\i0 Consists of:}
\par\plain {\f0\fs24\b0\i0 -self destruct set - set of accounts that will be discarded following the transaction - As}
\par\plain {\f0\fs24\b0\i0 -log series - this is a series of archived and indexable \loch\af0\hich\af0\dbch\af0\uc1\u8216\'91checkpoints\u8217\'92 in VM code execution that allow for contract-calls to be easily tracked (Al)}
\par\plain {\f0\fs24\b0\i0 -set of touched accounts - empty ones are deleted at the end of the transaction - At}
\par\plain {\f0\fs24\b0\i0 -refund balance  - Ar}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs24\b1\i0 Execution}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 The execution of a valid transaction beings with irrevocable change made to the state:}
\par\plain {\f0\fs24\b0\i0 -nonce of the account sender is incremented by 1 }
\par\plain {\f0\fs24\b0\i0 -balance is reduced by up front cost}
\par\plain {\f0\fs24\b0\i0 -Then message call or the contract creation is perfromed}
\par\plain {\f0\fs24\b0\i0 -refund counter has to be incremented for the accounts that were self-destructed}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 To finalize:}
\par\plain {\f0\fs24\b0\i0 -refundable amount + some allowance from the refund counter}
\par\plain {\f0\fs24\b0\i0 -Ether for gas given to miner}
\par\plain {\f0\fs24\b0\i0 -delete all self-destruct accounts + all touched but empty accounts}
\par\plain {\f0\fs24\b0\i0 -specify total gas used in transaction}
\par\plain {\f0\fs24\b0\i0 -specify logs created by this transaction}
\par\plain {\f0\fs24\b0\i0 -specify status code of this transaction}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs36\b1\i0 Contract Creation}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 There are a number of intrinsic parameters used when creating an account}
\par\plain {\f0\fs24\b0\i0 -sender - s}
\par\plain {\f0\fs24\b0\i0 -original transactor - o}
\par\plain {\f0\fs24\b0\i0 -available gas - g}
\par\plain {\f0\fs24\b0\i0 -gas price - p}
\par\plain {\f0\fs24\b0\i0 -endowment - v}
\par\plain {\f0\fs24\b0\i0 -arbitrary length byte array, initialization EVM code - i}
\par\plain {\f0\fs24\b0\i0 -present depth of the message-call/contract creation stack - e}
\par\plain {\f0\fs24\b0\i0 -permission to make modifications to the state - w}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 The address of the new account is defined as being the rightmost 160 bits of the Keccak hash of the RLP encoding of the structure containing only the sender and account nonce}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 The account nonce is set to 1}
\par\plain {\f0\fs24\b0\i0 Balance set as the value passed in}
\par\plain {\f0\fs24\b0\i0 The storage as empty}
\par\plain {\f0\fs24\b0\i0 Code hash as the keccak 256 bit hash of empty string}
\par\plain {\f0\fs24\b0\i0 Senders balance is also reduced by the value passed}
\par\plain {\f0\fs24\b0\i0 Account is initialized through the execution of the initializing EVM code (i) }
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs36\b1\i0 Message Call}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 In the case of executing a message call, several parameters are required}
\par\plain {\f0\fs24\b0\i0 -sender - s}
\par\plain {\f0\fs24\b0\i0 -transaction originator - o}
\par\plain {\f0\fs24\b0\i0 -recipient - r}
\par\plain {\f0\fs24\b0\i0 -account whose code is to be executed - c (usually same as recipient)}
\par\plain {\f0\fs24\b0\i0 -available gas - g}
\par\plain {\f0\fs24\b0\i0 -value - v}
\par\plain {\f0\fs24\b0\i0 -gas price - p}
\par\plain {\f0\fs24\b0\i0 -input data of the call, an arbitrary length byte array - d}
\par\plain {\f0\fs24\b0\i0 -present depth of the message-call/contract creation stack - e}
\par\plain {\f0\fs24\b0\i0 -permission to make modifications to the state - w}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Additionally, there is an out put byte array - o}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs36\b1\i0 Execution Model}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 Specifies how the system state is altered given bytecode instructions and small tuple of environmental data.}
\par\plain {\f0\fs24\b0\i0 Technically quasi-Turing complete since gas can limit programs from running forever (halting problem)}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 EVM is simple stack-based architecture}
\par\plain {\f0\fs24\b0\i0 Word size of the machine (and stack items) is 256 bit}
\par\plain {\f0\fs24\b0\i0 Memory model is simple word-addressed byte array, stack has max of 1024}
\par\plain {\f0\fs24\b0\i0 Independent storage model - word addressable word array - non volatile - maintained as part of system state}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Program code is stored in virtual Read only memory (ROM) that can only be accessed by special instructions}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Exceptions include stack underflow, invalid instruction, out of gas - all do not leave state changes intact.  Machine halts immediately and reports issue to execution agent.}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs24\b1\i0 Fees}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 Fees are charged under 3 distinct circumstances:}
\par\plain {\f0\fs24\b0\i0 -fee is intrinsic to the computation of the operation}
\par\plain {\f0\fs24\b0\i0 -gas may be deducted in order to form the payment to a subordinate message call or contract creation}
\par\plain {\f0\fs24\b0\i0 -may be paid due to increase in usage of memory}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Total fee for memory usage payable is proportional to smallest multiple of 32 bytes that are required such that all memory indices are included in the range.  This is JIT payment - referencing a memory address greater than 32 bytes of previously indexed memory will incur additional memory usage free.  Freed memory is refunded up front and execution fee waived, due to how expensive storage is considered.}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs24\b1\i0 Execution Environment}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 In addition to system state (\loch\af0\hich\af0\dbch\af0\uc1\u963\'73) and remaining gas (g), the following are needed:}
\par\plain {\f0\fs24\b0\i0 -address of the account which owns the code executing - Ia}
\par\plain {\f0\fs24\b0\i0 -sender address of the transaction that originated execution - Io}
\par\plain {\f0\fs24\b0\i0 -price of gas in the transaction that originated this execution - Ip}
\par\plain {\f0\fs24\b0\i0 -byte array that is input data to this execution - if execution agent is transaction, this would be transaction data - Id}
\par\plain {\f0\fs24\b0\i0 -address of the account which caused code to be executing - if the execution agent is a transaction, this would be the transaction sender - Is}
\par\plain {\f0\fs24\b0\i0 -value passed into this account as part of the same procedure as execution - if execution agent is transaction this would be the transaction value - Iv}
\par\plain {\f0\fs24\b0\i0 -byte array that is machine code to be executed - Ib}
\par\plain {\f0\fs24\b0\i0 -the block header of the present block - IsubH}
\par\plain {\f0\fs24\b0\i0 -depth of present message-call or contract-creation - Ie}
\par\plain {\f0\fs24\b0\i0 -permission to make modifications to the state - Iw}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs36\b1\i0 Blocktree to blockchain}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 The canonical blockchain is a path from root to leaf throughout the entire block tree.  To have consensus over which path is is, we identify the path that has had the most computation done upon it (the heaviest path).}
\par\plain {\f0\fs24\b0\i0 The heaviest path is the block number of the leaf, equivalent to the number of blocks (not counting the unmined genesis block).  The longer the path, the great total mining effort.}
\par\plain {\f0\fs24\b0\i0 Since the block header includes the difficulty, the header alone is enough to validate the computation done.}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs36\b1\i0 Block Finalization}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 Process of finalizing:}
\par\plain {\f0\fs24\b0\i0 1-validate ommers/uncles (if mining, determine ommers/uncles)}
\par\plain {\f0\fs24\b0\i0 2-validate transactions (if mining, determine transactions)}
\par\plain {\f0\fs24\b0\i0 3-apply rewards}
\par\plain {\f0\fs24\b0\i0 4-verify state and block nonce (if mining, compute valid state and block nonce)}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs24\b1\i0 Ommer validation}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 Verify each ommer header is both valid header and satisfies the relation of Nth generation ommer to the present block is less than or equal to 6}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs24\b1\i0 Transaction validation}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 Given gasUsed must correspond faithfully to the transactions listed - total gas used in block must be equal to the acculated gas used according to the final transaction}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs24\b1\i0 Reward Application}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 Involves raising the balance of beneficiary accounts of the block and each included ommer (and 1/32 of block reward to blocks beneficiary).}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f1\fs24\b1\i0 State and Nonce validation}
\par\pard\plain \fi360\ltrch\loch {\f0\fs24\b0\i0 Check status code, log, and cumulative gas after each transaction and apply finalization function}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0}