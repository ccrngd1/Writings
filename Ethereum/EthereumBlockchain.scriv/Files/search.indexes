<?xml version="1.0" encoding="UTF-8"?>
<SearchIndexes Version="1.0">
    <Documents>
        <Document ID="4">
            <Title>Preliminary</Title>
            <Synopsis>- the writing assignment, timelines and deadlines, brainstorming structure</Synopsis>
        </Document>
        <Document ID="6">
            <Title>The Assignment</Title>
            <Synopsis>This is the exact wording of the writing assignment from your teacher or class.
</Synopsis>
        </Document>
        <Document ID="7">
            <Title>Structure Brainstorm</Title>
            <Synopsis>Brainstorm the outline/structure of the essay, given the assignment details and the type of essay you’re asked to write.</Synopsis>
        </Document>
        <Document ID="8">
            <Title>Essay Draft</Title>
            <Synopsis>- the ever-changing bits and pieces of your first draft
- focus on structural components of the essay in the binder</Synopsis>
        </Document>
        <Document ID="10">
            <Title>Introduction to Blockchain and Ethereum</Title>
            <Synopsis>- documents in this folder are elements of the main body
- rearrange order to reflect the narrative/argumentative flow of the essay, and your structure brainstorm</Synopsis>
        </Document>
        <Document ID="11">
            <Title>Conclusion</Title>
            <Synopsis>- summarize thesis and main argumentative points
- optional commentary</Synopsis>
        </Document>
        <Document ID="12">
            <Title> References</Title>
            <Synopsis>- references cited in the essay</Synopsis>
        </Document>
        <Document ID="13">
            <Title>Timeline and Scheduling</Title>
            <Synopsis>The due date of your essay, with estimated timeline for research, draft writing and revisions.</Synopsis>
        </Document>
        <Document ID="14">
            <Title>Revisions</Title>
            <Synopsis>- revisions of the draft based on second-readings, feedback from your teacher or other reviewers</Synopsis>
        </Document>
        <Document ID="16">
            <Title>Conclusion</Title>
            <Synopsis>- summarize thesis and main argumentative points
- optional commentary</Synopsis>
        </Document>
        <Document ID="17">
            <Title>References</Title>
            <Synopsis>- references cites in the essay</Synopsis>
            <Text>DR. GAVIN WOOD. ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER. 2019-08-16
URL https://ethereum.github.io/yellowpaper/paper.pdf</Text>
        </Document>
        <Document ID="18">
            <Title>Links</Title>
            <Synopsis>- drag and drop web links into this folder</Synopsis>
        </Document>
        <Document ID="22">
            <Title>Documents</Title>
            <Synopsis>- import research documents into this folder (e.g. pdf files, Word files, images, videos, etc.)</Synopsis>
        </Document>
        <Document ID="24">
            <Title>Final Versions</Title>
            <Synopsis>- pdf or Word or other versions of the final submitted essay
- may include other kinds of documents associated with the essay (eg. PowerPoint or Keynote files used for a presentation)</Synopsis>
        </Document>
        <Document ID="25">
            <Title>Main Body</Title>
            <Synopsis>- documents in this folder are elements of the main body
- rearrange order to reflect the narrative/argumentative flow of the essay, and your structure brainstorm</Synopsis>
        </Document>
        <Document ID="27">
            <Title>Version 1 - Aug 2019</Title>
            <Synopsis>- revisions of the draft based on second-readings, feedback from your teacher or other reviewers</Synopsis>
            <Text>D
</Text>
        </Document>
        <Document ID="34">
            <Title>Building a fully decentralized user profile app</Title>
            <Text>https://medium.com/@sebinatx/building-a-fully-decentralized-user-profile-dapp-on-ethereum-and-ipfs-e55afac35718

Setting up truffle
…

Setting up Ganache
…

Setting up MetaMask
…

Solidity
Solidity is the de facto programming language for developing Ethereum Smart
Contracts. It's strongly typed (a good thing, given the nature of the business), and
arguably hackish and difficult to use. We'll still use it here for our purposes -- it does the
job.

Tip: this article is very helpful in understanding how to work with Solidity and how to
develop basic CRUD functionality.

Tip: try out Remix for help learning Solidity and developing smart contracts. Develop and
refine your initial contracts on Remix, then move over to your local network (you can also
connect Remix to your local network BTW).

IPFS
Not specific to blockchain
</Text>
        </Document>
        <Document ID="35">
            <Title>DApps</Title>
        </Document>
        <Document ID="37">
            <Title>What are Ethereum Uncles</Title>
            <Text>What are Ethereum Uncles

https://themerkle.com/what-are-ethereum-uncles/

an uncle is a referred to as a network block which would normally be considered an orphan.  Uncles work in a similar way, but there is a major difference between bitcoin orphan and ethereum uncle

Ethereum miners are incentivized to include uncles everytime a block is mined.
Bitcoin does not offer an incentive for including orphaned blocks.


Reasons:

1. decreases decentralization in Ethereum mining. Like it or not, but cryptocurrency mining is often a very centralized activity. Even though there are many different mining pools to choose from, centralization is still present

Rewarding miners for producing uncles is an interesting incentive. Not everyone wants to mine at a large pool, and this move effectively promotes solo mining to a certain degree. It is also an incentive to join smaller mining pools, as uncles will still yield some form of reward. Any miner who is not part of a big pool often has to deal with slight network delays when new blocks are discovered. In some cases, uncles can be discovered with a split second off the official block being mined.

2.  increasing overall Ethereum chain security.


Uncles are still subject to the same mining work as conducted to mine the main chain blocks. This approach results in wasting less computing resources on stale blocks, which can only be beneficial for the network as a whole. Do keep in mind including uncles also creates a bit more blockchain “bloat,” which is becoming somewhat of a recent issue with Ethereum.
One big potential issue with this uncle system is how it can create incentives for miners -or even pools- to mine empty blocks. As we have seen on the Bitcoin network, mining empty blocks serves no real purpose whatsoever. An empty uncle block would make no real sense either, yet there is a reward associated with it. So far, it does not appear anyone is purposefully mining empty uncle blocks, but that situation may come to change over time. The whole concept is still very interesting.</Text>
        </Document>
        <Document ID="38">
            <Title>Eth</Title>
        </Document>
        <Document ID="39">
            <Title>YellowPaper</Title>
        </Document>
        <Document ID="40">
            <Title>What and how application data is stored in Ethereum</Title>
            <Text>Where and how application data is stored in Ethereum?

https://www.lsenta.io/posts/storage-and-dapps-on-ethereum-blockchain/


The Account Machine
The Ethereum Software is a Transaction Processing System: 
1. We have a state: the set of all accounts and their balance, 
2. We apply one or more transactions, 
3. We get a new state: an updated set of accounts and their balances.


Robot Accounts
Every account has an owner and a balance. 
But some of these accounts are special; they own themselves.
At creation time, we give them a piece of code and memory. 

A Smart Contract is a smart bank account. I find the Contract term unclear, think of them as Robot Accounts.

It’s a Robot that executes some code when it receives transactions. 

This transaction happens within the Blockchain. 

A Smart Contract won’t fail because of a power outage in a Datacenter.

A Smart Contract has a balance, some code, and some storage. This storage is persistent, and that’s where we’ll find a DAPP data.

These Robot’s Actions are instructions in the Ethereum Virtual Machine (EVM).

There are instructions to read in storage, instructions to write, etc. 

They all have a cost in gas, and that cost will constrain how much storage we may use.

Storage of Robot Accounts
It’s a big dictionary (key-value store) that maps keys to values. Keys are strings of 32 bytes. We can have 2^(32 x 8) bits = 2^256 different keys. Same for values.

It’s like a Redis, RocksDB or LevelDB storage.

2^256 keys x 32 bytes (values) is around 10^63 PETABYTES. You would need billions of time the age of the universe to go through this amount of data with an SSD. 

We can assume there’s no storage limit for a DAPP.

DAPP Fuel
For every transaction, we add some Ether

The emitter of the transaction pays this tax to motivate the miners to process the transaction. Miners ensure the network is reliable and we reward them with some Ether. Gas is the fuel of the Ethereum Machine.

Storage Cost
The cost of each instruction in a Smart Contract will limit the amount of storage it uses. 

Ethereum allows for a theoretically infinite storage space, BUT you have to provide gas for every read/write operation.

1. You can read from the Blockchain for free
If you install the Ethereum client and you get into the network. Even without mining, the client will synchronize all the blockchain data. All the data of every DAPP on Ethereum is then available on your machine, without any gas cost.

2. Storage Costs doesn’t depend on duration
Each member of the network may replay the entire history of transactions. By design, the data stored in Ethereum is never deleted, so there’s no benefit to removing a key-value.</Text>
        </Document>
        <Document ID="41">
            <Title>blockchain, whats the point for the developer</Title>
            <Text>Blockchain, what’s the point for a developer?

https://www.lsenta.io/posts/the-point-of-the-blockchain/


This Consensus Problem is well known, a few example of systems that use or provide a consensus system in one way or another.

Blockchain is an available and crash-resilient consensus WHILE being able to deal with hostile participants. With the ability to work in an open community.

I’ve heard a lot of other things: immutability of the logs, anonymous transactions, permanent data storage, etc. These are technical details, consequences or necessities of the consensus.

Fundamentally, the Blockchain is an apparatus that generates consensus in a potentially hostile environment.

</Text>
        </Document>
        <Document ID="42">
            <Title>Getting deep into ethereum: how data is stored in ethereum</Title>
            <Text>Getting Deep Into Ethereum: How Data Is Stored In Ethereum

https://hackernoon.com/getting-deep-into-ethereum-how-data-is-stored-in-ethereum-e3f669d96033

dive into Ethereum’s data storage layer. 

We will introduce the concept of blockchain “state”. 

We will cover the theory behind the Patricia Trie data structure and demonstrate Ethereum’s concrete implementation of tries using Google’s leveldb database.



Ethereum world state is able to manage account balances, and more. 
The state of Ethereum is not an abstract concept. It is part of Ethereum’s base layer protocol. As the yellow paper mentions, Ethereum is a transaction-based “state” machine; a technology on which all transaction-based state machine concepts may be built.

Chain starts with ‘Genesis block’ at block 0. Transactions are tracked from that state forward (stored in state trie)

Importantly, data such as account balances are not stored directly in the blocks of the Ethereum blockchain. 
Only the root node hashes of the transaction trie, state trie and receipts trie are stored directly in the blockchain. 
the root node hash of the storage trie (where all of the smart contract data is kept) actually points to the state trie, which in turn points to the blockchain. We will zoom in and cover all of this in more detail soon.

￼


There are two vastly different types of data in Ethereum; permanent data and ephemeral data. 
An example of permanent data would be a transaction. Once a transaction has been fully confirmed, it is recorded in the transaction trie; it is never altered. 
An example of ephemeral data would be the balance of a particular Ethereum account address. The balance of an account address is stored in the state trie and is altered whenever transactions against that particular account occur. 



State Trie


There is one, and one only, global state trie in Ethereum.

This global state trie is constantly updated.

The state trie contains a key and value pair for every account which exists on the Ethereum network.

The “key” is a single 160 bit identifier (the address of an Ethereum account).

The “value” in the global state trie is created by encoding the following account details of an Ethereum account (using the Recursive-Length Prefix encoding (RLP) method):
- nonce
- balance
- storageRoot
- codeHash

￼




Storage Trie

A storage trie is where all of the contract data lives. 

Each Ethereum account has its own storage trie. 

A 256-bit hash of the storage trie’s root node is stored as the storageRoot value in the global state trie (which we just discussed).


￼



Transaction trie - one per block

Each Ethereum block has its own separate transaction trie. 

A block contains many transactions. The order of the transactions in a block are of course decided by the miner who assembles the block. The path to a specific transaction in the transaction trie, is via (the RLP encoding of) the index of where the transaction sits in the block. 

Mined blocks are never updated; the position of the transaction in a block is never changed. This means that once you locate a transaction in a block’s transaction trie, you can return to the same path over and over to retrieve the same result.

￼


Concrete examples of tries in Ethereum

The main Ethereum clients use two different database software solutions to store their tries. Ethereum’s Rust client Parity uses rocksdb. Whereas Ethereum’s Go, C++ and Python clients all use leveldb.

Ethereum and leveldb

LevelDB is an open source Google key-value storage library which provides, amongst other things, forward and backward iterations over data, ordered mapping from string keys to string values, custom comparison functions and automatic compression. The data is automatically compressed using “Snappy” an open source Google compression/decompression library. Whilst Snappy does not aim for maximum compression, it aims for very high speeds. Leveldb is an important storage and retrieval mechanism which manages the state of the Ethereum network. As such, leveldb is a dependency for the most popular Ethereum clients (nodes) such as go-ethereum, cpp-ethereum and pyethereum.

Whilst the implementation of the trie data structure can be done on disk (using database software such as leveldb) it is important to note that there is a difference between traversing a trie and simply looking at the flat key/value database.

</Text>
        </Document>
        <Document ID="43">
            <Title>Images</Title>
        </Document>
        <Document ID="44">
            <Title>DeepInEthere_blockANDtrieRoots</Title>
        </Document>
        <Document ID="45">
            <Title>DeepInEthere_stateTrie</Title>
        </Document>
        <Document ID="46">
            <Title>DeepInEthere_storageTrie</Title>
        </Document>
        <Document ID="47">
            <Title>DeepInEthere_transactionTrie</Title>
        </Document>
        <Document ID="48">
            <Title>Getting deep into EVM</Title>
            <Text>
￼
￼

￼


Ethereum Contracts

Basics

Smart contracts are just computer programs, and we can say that Ethereum contracts are smart contracts that run on the Ethereum Virtual Machine. The EVM is the sandboxed runtime and a completely isolated environment for smart contracts in Ethereum. This means that every smart contract running inside the EVM has no access to the network, file system, or other processes running on the computer hosting the VM.

As we already know, there are two kinds of accounts: contracts and external accounts. Every account is identified by an address, and all accounts share the same address space. The EVM handles addresses of 160-bit length.

￼

￼


Every account consists of a balance, a nonce, bytecode, and stored data (storage). However, there are some differences between these two kinds of accounts. For instance, the code and storage of external accounts are empty, while contract accounts store their bytecode and the merkle root hash of the entire state tree. Moreover, while external addresses have a corresponding private key, contract accounts don’t. The actions of contract accounts are controlled by the code they host in addition to regular cryptographic signing of every Ethereum transaction.

￼

Message Calls
Contracts can call other contracts through message calls. Every time a Solidity contract calls a function of another contract, it does so by producing a message call. Every call has a sender, a recipient, a payload, a value, and an amount of gas. The depth of message call is limited to less than 1024 levels.




￼


Data Management

The EVM manages different kinds of data depending on their context, and it does that in different ways. We can distinguish at least four main types of data: stack, calldata, memory, and storage, besides the contract code. Let’s analyze each of these:

￼

Stack
The EVM is a stack machine, meaning that it doesn’t operate on registers but on a virtual stack. The stack has a maximum size of 1024. Stack items have a size of 256 bits; in fact, the EVM is a 256-bit word machine (this facilitates Keccak256 hash scheme and elliptic-curve computations). Here is where most opcodes consume their parameters from.



￼


Calldata
The calldata is a read-only byte-addressable space where the data parameter of a transaction or call is held. Unlike the stack, to use this data you have to specify an exact byte offset and number of bytes you want to read.

￼

Memory
Memory is a volatile read-write byte-addressable space. It is mainly used to store data during execution, mostly for passing arguments to internal functions. Given this is volatile area, every message call starts with a cleared memory. All locations are initially defined as zero. As calldata, memory can be addressed at byte level, but can only read 32-byte words at a time.

Memory is said to “expand” when we write to a word in it that was not previously used. Additionally to the cost of the write itself, there is a cost to this expansion, which increases linearly for the first 724 bytes and quadratically after that.


Storage
Storage is a persistent read-write word-addressable space. This is where each contract stores its persistent information. Unlike memory, storage is a persistent area and can only be addressed by words. It is a key-value mapping of 2²⁵⁶ slots of 32 bytes each. A contract can neither read nor write to any storage apart from its own. All locations are initially defined as zero.

The amount of gas required to save data into storage is one of the highest among operations of the EVM. This cost is not always the same. Modifying a storage slot from a zero value to a non-zero one costs 20,000. While storing the same non-zero value or setting a non-zero value to zero costs 5,000. However, in the last scenario when a non-zero value is set to zero, a refund of 15,000 will be given.

Solidity will automatically map every defined state variable of your contract to a slot in storage. The strategy is fairly simple — statically sized variables (everything except mappings and dynamic arrays) are laid out contiguously in storage starting from position 0.

For dynamic arrays, this slot (p) stores the length of the array and its data will be located at the slot number that results from hashing p(keccak256(p)). For mappings, this slot is unused and the value corresponding to a key k will be located at keccak256(k,p). Bear in mind that the parameters of keccak256 (k and p) are always padded to 32 bytes.

</Text>
        </Document>
        <Document ID="49">
            <Title>DeepInEVM_vmArch</Title>
        </Document>
        <Document ID="50">
            <Title>DeepInEVM_vmLayer</Title>
        </Document>
        <Document ID="51">
            <Title>DeepInEVM_execution</Title>
        </Document>
        <Document ID="52">
            <Title>DeepInEVM_account</Title>
        </Document>
        <Document ID="53">
            <Title>DeepInEVM_accountsCompare</Title>
        </Document>
        <Document ID="54">
            <Title>DeepInEVM_abi</Title>
        </Document>
        <Document ID="55">
            <Title>DeepInEVM_msgCaller</Title>
        </Document>
        <Document ID="56">
            <Title>DeepInEVM_machineSpace</Title>
        </Document>
        <Document ID="57">
            <Title>DeepInEVM_stack</Title>
        </Document>
        <Document ID="58">
            <Title>DeepInEVM_memory</Title>
        </Document>
        <Document ID="59">
            <Title>Helpful commands</Title>
            <Text>Helpful: geth console commands
admin.nodeInfo.enode
net.listening
net.peerCount
admin.peers
eth.coinbase
eth.getBalance(eth.coinbase)
personal
eth.accounts
miner.setEtherbase(web3.eth.accounts[0])
miner.setEtherbase(“0xae13d41d66af28380c7af6d825ab557eb271ffff”)
miner.start()
miner.stop()
miner.hashrate
eth.getBlock(0)
eth.getBlock(“latest”)
eth.blockNumber 
web3.eth.getBlock(BLOCK_NUMBER).hash
eth.syncing
debug.verbosity(6) // highest logging level, 3 is default</Text>
        </Document>
        <Document ID="60">
            <Title>How to store data on ethereum</Title>
            <Text>How to store data on ethereum blockchain

The data on Ethereum Blockchain is stored using tire data structures. Before going ahead, we would like you to know that it is completely sensible that permanent data like mined transaction and temporary data like account balance should be stored separately. Ethereum makes use of this trie data structure to manage temporary and permanent data. We can say that Etherum is like a bank.

Only after a transaction is confirmed, then it is recorded in the transaction trie. Ephemeral or temporary data like account address is stored in the state trie, and it changes and gets updated. Thus it makes complete sense to keep both temporary and permanent should be stored separately and hence we have three tries for managing and storing data.

There three types of the trie in the Ethereum Blockchain:

State Trie
Storage Trie
And Transaction Trie

Storage trie
As the name itself indicates, storage trie is where the contract data is present. Every ethereum account has its storage trie. 256-bit hash of the storage trie’s root node is stored in the global state trie as storageRoot.

Transaction trie
Every Ethereum block has its transaction trie. Every block contains transactions. The order of the transaction present in every block is based on the course of addition of transaction to the block. The position of the block never changes, the path of a particular transaction is via the index of where the transaction sits in the block. In simple words, it means, that you can locate transaction you can go back on the same path again and again and get the same result.

An important point to note here is that data like account balance are not stores directly in the blocks. Only the root node hashes of the transaction trie, recept trie and state tries are stored in the Blockchain.</Text>
        </Document>
        <Document ID="62">
            <Title>Ethereum accounts</Title>
            <Text>https://medium.com/coinmonks/ethereum-account-212feb9c4154

Account state
The account state consists of four components, which are present regardless of the type of account:

nonce: If the account is an externally owned account, this number represents the number of transactions sent from the account’s address. If the account is a contract account, the nonce is the number of contracts created by the account.

balance: The number of Wei owned by this address. There are 1e+18 Wei per Ether.

storageRoot: A 256-bit hash of the root node of a Merkle Patricia tree that encodes the storage contents of the account (a mapping between 256-bit integer values), encoded into the trie as a mapping from the Keccak 256-bit hash of the 256-bit integer keys to the RLP-encoded 256-bit integer values. This tree encodes the hash of the storage contents of this account, and is empty by default.

codeHash: The hash of the EVM (Ethereum Virtual Machine) code of this account — this is the code that gets executed should this address receive a message call; it is immutable and thus, unlike all other fields, cannot be changed after construction. All such code fragments are contained in the state database under their corresponding hashes for later retrieval. For contract accounts, this is the code that gets hashed and stored as the codeHash. For externally owned accounts, the codeHash field is the hash of the empty string.


Externally owned accounts (EOAs)

An externally controlled account
has an ether balance,
can send transactions (ether transfer or trigger contract code),
is controlled by private keys,
has no associated code.

Contract accounts (some articles call Contract Wallet)
A contract
has an ether balance,
has associated code,
code execution is triggered by transactions or messages (calls) received from other contracts.
when executed — perform operations of arbitrary complexity (Turing completeness) — manipulate its own persistent storage, i.e., can have its own permanent state — can call other contracts
Contract accounts in Exchange Send Ether (ETH) to a user account has a fee of 21000 gas but sending ETH to a contract has a higher fee, which depends on the contract code and data being sent in the transaction.

Advantages of contract accounts over User Account:
Contract account can list incoming transactions
Contract account can be setup as Multisig Accounts
A Multisig Account can be structured such that it has a daily limit which you specify, and only if the daily limit is exceeded will multiple signatures be required

Disadvantages of contract accounts over User Accounts:
Contract accounts incur a cost whenever you use them.


External accounts can send meessages to other Ext or Contract acct.

External to External is a value send (ETH)
External to contract kicks off smart contract
Contract can not initiate transactions but can call other contracts on behalf of Ext caller

Types of contract account
There are two type of contract account — Simple account &amp; Multisig( Multisignature) account
Simple account &amp; Multisig account are created and owned by Accounts.
Simplet account : Only one account bother creates and owns the account.
Multisig account : A Multisig Wallet has several owner Accounts one of which will also be the creator Account.



</Text>
        </Document>
        <Document ID="63">
            <Title>How does ethereum work anyway</Title>
            <Text>https://medium.com/@preethikasireddy/how-does-ethereum-work-anyway-22d1df506369

The Ethereum blockchain is essentially a transaction-based state machine. In computer science, a state machine refers to something that will read a series of inputs and, based on those inputs, will transition to a new state.

With Ethereum’s state machine, we begin with a “genesis state.” This is analogous to a blank slate, before any transactions have happened on the network. When transactions are executed, this genesis state transitions into some final state. At any point in time, this final state represents the current state of Ethereum.

The state of Ethereum has millions of transactions. These transactions are grouped into “blocks.” A block contains a series of transactions, and each block is chained together with its previous block.

￼
￼

To cause state transition, must have a transaction and transaction must be valid.
To be valid, must be verified via mining by a miner.
A miner will collect transactions into a block and submit it to the network.
Miner submits ‘proof of work’ to show the block is valid.



The blockchain can be seen as a transactional singleton machine with shared state.  There can never be multiple active states or chains.  Any difference in the chain results in a ‘fork’, the network must agree on what branch of the fork is the valid state.

￼
￼

Ethereum uses GHOST protocol (greedy heaviest observed subtree)
GHOST says we must pick the path that has had the most computation done upon it. 



The main components of Ethereum are
Accounts
State
Gas and fees
Transacions
Blocks
Transaction executions
Mining
Proof of work


Accounts

Global state of Ethereum is comprised of many accounts that interact by passing messages (transactions).  Each account has a state with a 20byte address. An address is a 160 bit id used to identify account.

External accounts - controlled by private keys and have no code associated with them
Contract accounts - controlled by their contract code

External vs contract accounts
External can send messages directly to other external accounts or contracts by creating creating and signing transaction using private key.
External to external can only be a value transfer
Contract accounts can not initiate transactions but can call contracts on behalf of calling external account

Account State
Has 4 components
Nonce - for external accounts, this is the number of transactions sent from this account. If the account is a contract account, it is the number of contracts created by the account.
Balance - number of wei owned by this address
StorageRoot - hash of the root node. This tree encodes the hash of the storage contents of this account, empty by default
CoeHash - hash of the EVM code of this account for contract accounts. Empty for external accounts


World State
Global state consists of mapping between account addresses and account state - this mapping is stored in Merkle Patricia tree (Merkle tree, merkle trie). Tree is composed of:

a large number of leaf nodes at the bottom of the tree that contain the underlying data
a set of intermediate nodes, where each node is the hash of its two child nodes
a single root node, also formed from the hash of its two child node, representing the top of the tree

This tree structure is used for State, Transaction, Receipts, Storage

￼
￼

A result of using this tree structure is that either the hashes or the full contents of the tree can be sent to nodes in the network.  If only hashes are sent, this is considered ‘light clients’ or ‘light nodes’ and allow for traversing the entire blockchain but does not contain the detailed transaction or state data that exists.  
A full archive, full copy, or full node will require all the data and the hashes.  Miners are required to keep a full history to mine new blocks.  New miners that are added to the network must begin with the genesis block and replay all transactions to verify the next node.  Full copies are required for miners and for querying historical data.
Nodes will often not need a full copy, instead it is possible to download just the chain of headers, without executing transactions or retreiving state data. These are called Light Nodes and have access to hashes of the three tries.



Gas and payment
Every computation that occurs as a result of a transaction on the Ethereum network incurs a fee, that fee is called ‘gas’

Gas is the unit used to measure fee required.  

Every transaction has ‘Gas Price’ and ‘Gas Limit’
Gas price is in ‘gwei’ = 1.000.000.000 wei
Gas limit is the total number (max) of gas that the sender is willing to spend.  This may not be completely used, and any remaining after all transactions have completed are refunded to the sender.
Any gas spent on the transaction goes to the miner.
Miners are more likely to pick higher yielding transactions to mine, are able to advertise min gas amount they are willing to mine.

￼
￼
￼


Storage fees
There is a fee for computation as well as storage
Total fee is proportional to the smallest multiple of 32 bytes used
If space is freed by a transaction, there may be a refund back to the sender



Fee purpose
Every operations affects every node on the network, so there has to be some cost on the submitter to prevent abuse.
Computation in the EVM is expensive, and given smart contracts can contain any logic and are susceptible to the halting problem (potentially infintely running) this allows a maximum amount of time to run on the EVM in the form of gas.


Transaction and Messages
Ethereum is a transaction based machine; transactions between different accounts are what move from one state to the next.

A transaction is cryptographically signed piece of instruction that is generated by an externally owned account, serialized, and submitted to the blockchain

2 types: message calls and contract creations

All transactions:
-nonce: a count of the number of transactions sent by the sender.
-gasPrice: the number of Wei that the sender is willing to pay per unit of gas required to execute the transaction.
-gasLimit: the maximum amount of gas that the sender is willing to pay for executing this transaction. This amount is set and paid upfront, before any computation is done.
-to: the address of the recipient. In a contract-creating transaction, the contract account address does not yet exist, and so an empty value is used.
-value: the amount of Wei to be transferred from the sender to the recipient. In a contract-creating transaction, this value serves as the starting balance within the newly created contract account.
-v, r, s: used to generate the signature that identifies the sender of the transaction.
-init (only exists for contract-creating transactions): An EVM code fragment that is used to initialize the new contract account. init is run only once, and then is discarded. When init is first run, it returns the body of the account code, which is the piece of code that is permanently associated with the contract account.
-data (optional field that only exists for message calls): the input data (i.e. parameters) of the message call. For example, if a smart contract serves as a domain registration service, a call to that contract might expect input fields such as the domain and IP address.

￼

Blocks
All transactions are grouped together into blocks
A blockchain contains series of blocks chained together

Consists of:
-block header
-information about the transactions included in that block
-set of block headers for current blocks ommers

Ommers
Ommer is a block whose parent is equal to current blocks parents parent

Because of the way Ethereum is built, block times are much lower (~15 seconds) than those of other blockchains, like Bitcoin (~10 minutes). This enables faster transaction processing. However, one of the downsides of shorter block times is that more competing block solutions are found by miners. These competing blocks are also referred to as “orphaned blocks” (i.e. mined blocks do not make it into the main chain).
The purpose of ommers is to help reward miners for including these orphaned blocks. The ommers that miners include must be “valid,” meaning within the sixth generation or smaller of the present block. After six children, stale orphaned blocks can no longer be referenced (because including older transactions would complicate things a bit).

Ommer blocks receive a smaller reward than a full block. Nonetheless, there’s still some incentive for miners to include these orphaned blocks and reap a reward.


Block Header
Consists of:

-parentHash: a hash of the parent block’s header (this is what makes the block set a “chain”)
-ommersHash: a hash of the current block’s list of ommers
-beneficiary: the account address that receives the fees for mining this block
-stateRoot: the hash of the root node of the state trie (recall how we learned that the state trie is stored in the header and makes it easy for light clients to verify anything about the state)
-transactionsRoot: the hash of the root node of the trie that contains all transactions listed in this block
-receiptsRoot: the hash of the root node of the trie that contains the receipts of all transactions listed in this block
-logsBloom: a Bloom filter (data structure) that consists of log information
-difficulty: the difficulty level of this block
-number: the count of current block (the genesis block has a block number of zero; the block number increases by 1 for each each subsequent block)
-gasLimit: the current gas limit per block
-gasUsed: the sum of the total gas used by transactions in this block
-timestamp: the unix timestamp of this block’s inception
-extraData: extra data related to this block
-mixHash: a hash that, when combined with the nonce, proves that this block has carried out enough computation
-nonce: a hash that, when combined with the mixHash, proves that this block has carried out enough computation


Logs
Make it possible to track various transactions and messages
Contract can explicitly generate a log by defining “events”

Contains:
Loggers account address
Series of topics that represent events carried out by this transaction
Any data associated with events



Transaction recept
Logs stored in the header come from log info contained in the transaction receipt
Ethereum generates receipt for every transaction

Contains:
-block number
-block hash
-transaction hash
-gas used by current transaction
-cumulative gas used in block after current transaction executed
-logs created when executing current transaction



Transaction Execution
Most complex part of Etherum protocol, how to transition from state N to state N+1

All transaction to be included in state transition must:
-be a properly formatted RLP (”recursive length prefix”) and is a data format used to encode nested arrays of binary data.
-valid transaction signature
-valid transaction nonce (must be equal to the sender accounts nonce)
-gas limit must be &gt;= than the intrinsic gas used by transaction 
-senders accounts must have enough Ether to cover gas cost

Once transactions have met this, transition begins
1) deduct gas cost from sender, increase sender account nonce by 1
2) transaction executes
3) computations required by transaction are processed
4) if successful, unused gas + refund for freeing storage are calculated for sender - this finalizes the state
5) miner is rewarded
6) gas used by transaction are added to the block gas counter
7) any self-destruct accounts are deleted



Contract Creation
To create a new contract account:
1) declare the address of the account
2) initialize account
2.1)set nonce to 0
2.2)if sender sent ether - set account balance to this value
2.3)deduct any sent ether from sender account
2.4)set storage as emtpy
2.5)set codeHash as hash of an empty string

Once initialize, can create account using ‘init code’ (constructor from the contract)

If contract is successful, cost is paid, including storage

Any ether from the initial value is sent back to sender

If Contract fails, state is reverted back to what it was before attempting to create the account (no partial success concerns)



Message Calls
The execution of a message call is similar to that of contract creation, however:
-does not include init code
-can contain input data
-can contain output data, which is used if a subsequent execution needs this data



Execution Model
The thing that handles processing transaction is Ethereum Virtual Machine

EVM is a stack based architecture - uses LIFO stack to hold temp values.  The size of each stack item is 256bit, stack has max size of 1024. EVM has memory, word-addressed byte arrays, is volatile.

EVM has storage, is non-volatile, (RAM) maintained as part of the system state.  EVM stores program code seperately in read-only-memory (ROM).

EVM has its own language “EVM bytecode”. High level languages such as Solidity compile down to this.

Before execution starts, must validate:
-system state
-remaining gas for computation
-address of account that owns the code to execute
-address of the sender that originated execution
-address of account that caused code to execute (could be different from original sender, such as contract calling contract)
-gas price of transaction that originated execution
-input data for this execution
-value (wei) passed to this account as part of current transaction
-machine code to be executed
-block header of current block
-depth of the present message class or contract creation stack
-memory and stack are emptied
-program counter set to zero

EVM executes transaction recursively (computing system state and machine state for each loop). System state is Ethereum Global State. 
Machine state consists:
-gas available
-program counter
-memory contents
-active number of words in memory
-stack contents

Each cycle of execution, gas is reduced and program counter increments

Continues looping until (reminds me of PLC code)
-Machine reach exceptional state (out of gas, invalid instruction, stack overflow, invalid flow, etc)
-Machine reaches controlled halt (end of execution process)

If execution doesnt reach exceptional state, but reaches “controlled” or normal halt, the machine generates anew sate.



How block gets finalized
How block of many transactions gets finalized

“Finalized” can be two things 
-New block - referring to process required for mining the block
-Existing block - referring to the process of validating the block

Requirements to be finalized (for both types)
1-validate ommers (determine ommers if mining new block)
Each ommer block within the block header must be a valid header and be within the 6th generation of the present block

2-validate transaction (determine transaction if mining new block)
GasUsed number on block must be equal to cumulative gas used by all transactions listed in block

3-apply rewards (if mining new block)
Mining address is given 5 Ether for mining the block. For each ommer, awarded 1/32 of current block reward. Miner of ommers are award small amount

4-verify state and nonce (compute state and nonce if mining new block)
Ensure all transactions and resulting state changes are applied


Mining Proof of Work
Skipped

</Text>
        </Document>
        <Document ID="64">
            <Title>ethereumAnyway_states</Title>
        </Document>
        <Document ID="65">
            <Title>ethereumAnyway_blockStates</Title>
        </Document>
        <Document ID="66">
            <Title>ethereumAnyway_fork</Title>
        </Document>
        <Document ID="67">
            <Title>ethereumAnyway_ghost</Title>
        </Document>
        <Document ID="68">
            <Title>ethereumAnyway_stateTree</Title>
        </Document>
        <Document ID="69">
            <Title>ethereumAnyway_blockTree</Title>
        </Document>
        <Document ID="70">
            <Title>ethereumAnyway_gas</Title>
        </Document>
        <Document ID="71">
            <Title>ethereumAnyway_gasOut</Title>
        </Document>
        <Document ID="72">
            <Title>ethereumAnyway_gasLeftOver</Title>
        </Document>
        <Document ID="73">
            <Title>ethereumAnyway_transaction</Title>
        </Document>
        <Document ID="74">
            <Title>Ethereum Explained</Title>
            <Text>https://pegasys.tech/ethereum-explained-merkle-trees-world-state-transactions-and-more/


Merkle Trees

In a Merkle tree, the leaf nodes contain the hash of a block of data and the non-leaf nodes contain the hash of its children nodes

Any change to the underlying data causes the hash of the node referring to the data to change, which causes parent nodes hash to change as well, up the tree to the root.
This gives us 2 things:
1-dont need to compare all data across the leaf nodes to know if they have the same data - just compare root node hash
2-if we need to prove specific data is part of the tree, can perform Merkel proofs


World State
Is a mapping between addresses (accounts) and account states.
Is not stored on the blockchain but is stored in trie

Account State
nonce
Number of transactions sent from this address (if this is an External Owned Account – EOA) or the number of contract-creations made by this account (don’t worry about what contract-creations means for now).

balance
Total Ether (in Wei) owned by this account.

storageRoot
Hash of the root node of the account storage trie (we’ll see what the account storage is in a moment).

codeHash
For contract accounts, hash of the EVM code of this account. For EOAs, this will be empty.


Nonce, balance, storageRoot are mutable - are updated by EVM
CodeHash is immutable -meaning you can’t alter contract


Transaction
2 types:
1a)Transaction that transfer value
1b)Transaction that send message call
2)Transactions that deploy contract

nonce
Number of transactions sent by the account that created the transaction.

gasPrice
Value (in Wei) that will be paid per unit of gas for the computation costs of executing this transaction.

gasLimit
Maximum amount of gas to be used while executing this transaction.

to
If this transaction is transferring Ether, address of the EOA account that will receive a value transfer.
If this transaction is sending a message to a contract (e.g., calling a method in the smart contract), this is address of the contract.
If this transactions is creating a contract, this value is always empty.
value
If this transaction is transferring Ether, amount in Wei that will be transferred to the recipient account.
If this transaction is sending a message to a contract, amount of Wei payable by the smart contract receiving the message.
If this transaction is creating a contract, this is the amount of Wei that will be added to the balance of the created contract.
v, r, s
Values used in the cryptographic signature of the transaction used to determine the sender of the transaction.

data
(only for value transfer and sending a message call to a smart contract)

Input data of the message call (e.g., imagine you are trying to execute a setter method in your smart contract, the data field would contain the identifier of the setter method and the value that should be passed as parameter).

init
(only for contract creation)


Block

Consists of block header and block body

Block Body
Contains list of transaction included in this block and list of uncle (ommer) block headers

Block header
parentHash
Hash of the block header from the previous block. Each block contains a hash of the previous block, all the way to the first block in the chain. This is how all the data is protected against modifications (any modification in a previous block would change the hash of all blocks after the modified block).

ommersHash
Hash of the uncle blocks headers part of the block body.

beneficiary
Ethereum account that will get fees for mining this block.

stateRoot
Hash of the root node of the world state trie (after all transactions are executed).

transactionsRoot
Hash of the root node of the transactions trie. This trie contains all transactions in the block body.

receiptsRoot
Every time a transaction is executed, Ethereum generates a transaction receipt that contains information about the transaction execution. This field is the hash of the root node of the transactions receipt trie.

logsBloom
Bloom filter that can be used to find out if logs were generated on transactions in this block (if you want more details, check this Stack Overflow answer). This avoids storing of logs in the block (saving a lot of space).

difficult
Difficulty level of this block. This is a measure of how hard it was to mine this block (I’m not diving into the details of how this is calculated in this post).

number
Number of ancestor blocks. This represents the height of the chain (how many blocks are in the chain). The genesis block has number zero.

gasLimit
Each transaction consumes gas. The gas limit specifies the maximum gas that can be used by the transactions included in the block. It is a way to limit the number of transactions in a block.

gasUsed
Sum of the gas cost of each transaction in the block.

timestamp
Unix timestamp when the block was created. Note that due to the decentralized nature of Ethereum, we can’t trust in this value, especially when implementing smart contracts that have time related business logic.

extraData
Arbitrary byte array that can contain anything. When a miner is creating the block, it can choose to add anything in this field.

mixHash
Hash used to verify that a block has been mined properly (if you want to really understand this, read about the Ethash proof-of-work function).

nonce
Same as the mixHash, this value is used to verify that a block has been mined properly



Conclusion
Let’s do a quick recap about what we just saw! Basically, Ethereum has 4 types of tries:

1 The world state trie contains the mapping between addresses and account states. The hash of the root node of the world state trie is included in a block (in the stateRoot field) to represent the current state when that block was created. We only have one world state trie.

2 The account storage trie contains the data associated to a smart contract. The hash of the root node of the Account storage trie is included in the account state (in the storageRoot field). We have one Account storage trie for each account.

3 The transaction trie contains all the transactions included in a block. The hash of the root node of the Transaction trie is included in the block header (in the transactionsRoot field). We have one transaction trie per block.

4 The transaction receipt trie contains all the transaction receipts for the transactions included in a block. The hash of the root node of the transaction receipts trie is included in also included in the block header (in the receiptsRoot field); We have one transaction receipts trie per block.


And the objects that we discussed today are:

1 World state: the hard drive of the distributed computer that is Ethereum. It is a mapping between addresses and account states.

2 Account state: stores the state of each one of Ethereum’s accounts. It also contains the storageRoot of the account state trie, that contains the storage data for the account.

3 Transaction: represents a state transition in the system. It can be a funds transfer, a message call or a contract deployment.

4 Block: contains the link to the previous block (parentHash) and contains a group of transactions that, when executed, will yield the new state of the system. It also contains the stateRoot, the transactionRoot and the receiptsRoot, the hash of the root nodes of the world state trie, the transaction trie and the transaction receipts trie, respectively.</Text>
        </Document>
        <Document ID="75">
            <Title>EthereBlockchainMechanism</Title>
        </Document>
        <Document ID="76">
            <Title>Contracts</Title>
        </Document>
        <Document ID="77">
            <Title>Ethereum Smart Contracts</Title>
            <Text>https://www.commonlounge.com/discussion/dbc033c27763436cb9ee4789b3cd673e

￼￼
￼
If you want to send money to a contract, there would be an amount


￼</Text>
        </Document>
        <Document ID="78">
            <Title>ethereumSmartContracts_userCreateContract</Title>
        </Document>
        <Document ID="79">
            <Title>ethereumSmartContracts_userToContract</Title>
        </Document>
        <Document ID="80">
            <Title>ethereumSmartContracts_userToUser</Title>
        </Document>
        <Document ID="81">
            <Title>ethereumSmartContracts_transactionFields</Title>
        </Document>
        <Document ID="82">
            <Title>General notes</Title>
        </Document>
        <Document ID="83">
            <Title>General notes</Title>
            <Text>Why Trust a Smart Contract?
Smart contracts are designed and implemented within blockchains, and therefore they inherit some of the blockchain’s properties:

They’re immutable, which means a smart contract can never be changed and no one can tamper with or break a contract.
They’re distributed, which means that the outcome of the contract is validated by everyone in the network, just like any transaction on a blockchain. Distribution makes it impossible for an attacker to force control to release funds, as all other participants would detect such an attempt and mark it as invalid.








Smart Contract Benefits
Explicit programming algorithms in core and blockchain properties like decentralization, transparency, fraud resistance, and others make smart contracts a credible alternative for establishing business relations and performing transactions.

As an alternative to traditional contracts with a central business model, here are the benefits that smart contracts offer businesses:

Direct dealings with customers. Smart contracts remove the need for intermediaries and allow for transparent, direct relationships with customers.
Resistance to failure. Since businesses aren’t dependent on a third party, no single person or entity is in control of data or money. Decentralization means that even if any individual leaves the blockchain network, the network will continue to function with no loss of data or integrity.
More trust. Business agreements are automatically executed and enforced. Plus, these agreements are immutable and therefore unbreakable.
Fraud reduction. Since smart contracts are stored in a distributed blockchain network, their outcome is validated by everyone in that network. Therefore, no one can force control to release other people’s funds or data, as all other blockchain participants would spot this and mark such an attempt as invalid.
Cost efficiency. Eliminating intermediaries removes additional fees, allowing businesses and their customers not only to interact and transact directly but also to do so with low to no fees for transactions.
Record keeping. All contract transactions are stored in chronological order in the blockchain and can be accessed along with the complete audit trail.






How smart contracts work
It’s worth noting that bitcoin was the first to support basic smart contracts in the sense that the network can transfer value from one person to another. The network of nodes will only validate transactions if certain conditions are met.

But, bitcoin is limited to the currency use case.

By contrast, ethereum replaces bitcoin’s more restrictive language (a scripting language of a hundred or so scripts) and replaces it with a language that allows developers to write their own programs.

Ethereum allows developers to program their own smart contracts, or ‘autonomous agents’, as the ethereum white paper calls them. The language is ‘Turing-complete’, meaning it supports a broader set of computational instructions.

Smart contracts can:

Function as ‘multi-signature’ accounts, so that funds are spent only when a required percentage of people agree
Manage agreements between users, say, if one buys insurance from the other
Provide utility to other contracts (similar to how a software library works)
Store information about an application, such as domain registration information or membership records.






Misc
Call contract function as transaction will not give a result.
Can emit event
Can call a view method as non-transaction

Description			alter state?
pure	Doesn't read or write data	N
view	Reads, but doesn't write data	N
payable	Expecting payment of ether	Y
(unspecified)	Probably writes data	Y



pragma solidity &gt;=0.4.24;
 
contract NameContract {
 
    string private name = &quot;Ire&quot;;
 
    function getName() public view returns (string)
    {
        return name;
    }
    function setName(string newName) public
    {
        name = newName;
    }
}


Going back to my example contract, we can see that the function getName() has the type view which means it does not change the state of the contract. When calling this function via web3.js, we should use the call() method.

NameContract.methods.getName().call();



On the contrary, the setName() function doesn’t have a specified type and does change the state of the contract, in this case the value of the name variable. For these types of funtions, we should use the send() method.

NameContract.methods.setName(&quot;bitsofcode&quot;).send();</Text>
        </Document>
        <Document ID="84">
            <Title>Life cycle of ethereum transaction</Title>
            <Text>https://medium.com/blockchannel/life-cycle-of-an-ethereum-transaction-e5c66bae0f6e


Uses voting contract as a running example

Voting.deployed().then(function(instance) {
  instance.voteForCandidate('Nick', {gas: 140000, from: web3.eth.accounts[0]}).then(function(r) {
    console.log(&quot;Voted successfully!&quot;)
  })
})

￼


1 construct raw transaction object
VoteForCandidate() is a function containing

txnCount = web3.eth.getTransactionCount(web3.eth.accounts[0])
var rawTxn = {
    nonce: web3.toHex(txnCount),
    gasPrice: web3.toHex(100000000000),
    gasLimit: web3.toHex(140000),
    to: '0x633296baebc20f33ac2e1c1b105d7cd1f6a0718b',
    value: web3.toHex(0),
    data: '0xcc9ab24952616d6100000000000000000000000000000000000000000000000000000000'
};


-nonce: Each Ethereum account has a field called nonce to keep track of the total number of transactions that account has executed. Nonce is incremented for every new transaction and this allows the network to know the order in which the transactions need to be executed. Nonce is also used for the replay protection.

-gasPrice: Price per unit of gas you are willing to pay for this transaction. If you are executing your transaction on the Mainnet, here is a handy website from ETH Gas Station that recommends what you should set the gas price for your transaction to succeed in a reasonable amount of time. Gas prices are current measured in GWei and range from 0.1-&gt;100+Gwei. You will learn more about gas price and it’s impact later in this article.

-gasLimit: Maximum gas you are willing to pay for this transaction. This value insures that in case of an issue executing your transaction (like infinite loop), you account is not drained of all the funds. Once the transaction is executed, any remaining gas is sent back to your account.
to: The address to which you are directing this function call. This is the contract address (0x633296baebc20f33ac2e1c1b105d7cd1f6a0718b) of the Voting contract in our case.

-value: Total Ether you want to send. When we executevoteForCandidate, we are not sending any Ether and so the value is 0. If you were executing a transaction to send Ether to another person or a contract, you would set this value.

-data: 

Let’s see how this data field is calculated.

&gt; web3.sha3('voteForCandidate(bytes32)')
'0xcc9ab267dda32b80892b2ae9e21b782dbf5562ef3e8919fc17cab72aa7db9d59'

Take the first 4 bytes of this hash -&gt; ‘0xcc9ab267’
You then take the argument ‘Nick’ and convert to bytes32 and you get 52616d6100000000000000000000000000000000000000000000000000000000


2 Sign the transaction
Transactions have to be started by an externally owned account, to begin the transaction there must be a way of proving the account owner is the one initiating - this is done by signing the transaction

const privateKey = Buffer.from('e331b6d69882b4ab4ea581s88e0b6s4039a3de5967d88dfdcffdd2270c0fd109', 'hex')
const txn = new EthereumTx(rawTxn)
txn.sign(privateKey)
const serializedTxn = txn.serialize()


3 transaction is validated
Submission will validate the transaction 


4 transaction broadcast to the address
The signed transaction is broadcast to the larger network.  Once transaction is broadcast, original node will output the transaction id, this can be used to track the transaction.  This id is a hash of the signed transaction object.

Not all nodes will accept your transaction, some have a minimum gas price

transactionId = sha3(serializedTxn)

￼



5 miner node accepts the transaction
Ethereum network has a mix of miner and non-miner nodes (nodes and miners).  Miners are the ones that include transactions into blocks, these miners also maintain a transaction pool where transactions will be stored before a miner starts to evaluate them.

Miners will store transactions, sorted by gas price, the more expensive the gas price, the more likely it is to be picked up and included in the next block. This is configurable, and a miner is free to sort transactions in any manner they choose.  This allows for a miner to even mine the lowest cost transaction first.

Miners can only hold a finite number of transactions.  Therefore, if the network becomes flooded by a large number of high priced transactions they can fill up the transaction pools, meaning lower priced transactions may not be included and may need to be rebroadcast to the network.

To help with this, resubmitting a transaction with a higher gas price and re-using the nonce.  This will help improve the transactions chance of being picked up, while assuring it will only be mined one time.  If a transaction is resubmitted with a new nonce, there is the danger that both will eventually be mined.

￼


6 miner node finds a valid block and broadcasts to the network
Miners are able to pick up transactions to include in the block, but the total amount of gas to be used must be under a network wide, global limit.

Once the transactions have been chosen, they must be validated and included in a pending block and PoW or PoA begins.  Once the block has been validated, it will be added to the local copy of the blockchain.  Now, just like the raw transactions were broadcast to the network, this new version of the blockchain is broadcast.

7 local node receives/syncs new block
When a new node receives the new block, it must execute all transactions on that block and verify the new state.  




</Text>
        </Document>
        <Document ID="85">
            <Title>LifeCycleTransaction_vote</Title>
        </Document>
        <Document ID="86">
            <Title>LifeCycleTransaction_transactionPropogation</Title>
        </Document>
        <Document ID="87">
            <Title>LifeCycleTransaction_minerPool</Title>
        </Document>
        <Document ID="88">
            <Title>Yellow paper</Title>
            <Text>YellowPaper

Ethereum aims to build the generalized technology which all transaction based state machine concepts may be built. Further aims to provide end-developers a tightly integrated end-to-end system for build software on a trustful object message compute framework.
This credo clearly denotes the intentional focus on smart contracts and not on a specific cryptocurrency implementation, such as Ether.

Blockchain Paradigm
Ethereum can be viewed as a transaction-based state machine
Beginning with a genesis state and incrementally execute transactions to morph into some final state. (This final state is known as the canonical “version” of the world)

A state can include account balance, reputations, trust arrangements, data about the physical world. Transactions thus represent a valid arc between two states - vital being the the important part - there exist many more invalid than valid state changes. Invalid state changes could be thins such as reducing an account without increasing another account.

Transactions are turned into blocks, which are chained together using cryptographic hashes. Blocks function as a journal, recording a series of transactions together with the previous block and an identifier for the final state (but do not store the final state itself).

History
Since the system is decentralized, all parties have an opportunity to create a new block on some older, pre-existing block. If two or more parties submit new blockchains, a fork occurs, where nodes in the system will have differing version of the chain, potentially building more blocks on top of it. In order to form a consensus as to which resulting chain is correct, there must be a method to determine the correct chain, this is the GHOST protocol. 

Conventions

- σ - small sigma - world state
- µ - small mu - machine state
- Υ - big upsilon - ethereum state transition function
- C - big ‘c’ - general cost function (ie Csstore - cost for SSTORE operation)
- T - big ‘t’ - denote Ethereum transaction (ie - Tn - denotes nonce of a said transaction)
- n - small ‘n’ - denotes nonce 
- δ- small sigma - denotes number of items required on stack for given operation
- [ ] - denotes index into an array (ie µ[0] means machine state 0, σ[0] means account 0)



Blocks, state, and transactions
World State
World state is a mapping between address (160bit identifiers) and account states (a data structure serialized by RLP).
Not stored on the blockchain, but is implemented as modified Merkle Patricia tree (MMP trie).
The trie requires a simple database backend that maintains a mapping of byte arrays to byte arrays - we name this underlying database the state database.
This is an immutable data structure, which allows any previous state to be recalled simply by altering the root hash (root hashes are all stored on blockchain)

Account state (σ[a]) consists of:
-nonce - scalar value equal to number of transaction sent from this address (or number of contract-creations made by this account) - σ[a]n
-balance - scalar value equal to number of Wei owned by address - σ[a]b
-storageRoot - a 256bit hash of the root node of a MPtrie that encodes the storage contents of the account -σ[a]s
-codeHash - hash of the EVM code of this account - this is the code that gets executed should this address receive a message call; it is immutable and thus can not be changed after construction. All code fragments are contained in the state database under their corresponding hashes for later retrieval. - σ[a]c and thus the code may be denoted as b =&gt; KEC(b) = σ[a]c

An account is empty when it has no code, zero nonce, and zero balance.

The transaction
A transaction - T - is a single cryptographically-signed instruction constructed by an actor external of Ethereum.
There are two types of transactions:
-those that result in a message call
-those that result in creation of a new account with associated code (contract creation)

Transaction consists of
-none - scalar value equal to the number of transactions sent by sender - Tn
-gasPrice - scalar value equal to the number of Wei to be paid per unit of gas for all computation costs incurred as a result of the execution of this transaction - Tp
-gasLimit - scalar value equal to the max amount of gas that should be used in executing this transaction. This is paid up-front before any computation is done and my not be increased later (but unused portions may be refunded) - Tg
-to - the 160 address of the message calls recipient (or for contract creation 0 - Tt
-value - scalar value equal to the number of Wei to be transferred to the message calls recipient (or in contract creation, an endowment to the newly created account) - Tv
-v,r,s - values corresponding to the signature of the transaction used to determine the sender of the transaction - Tw, Tr, Ts
-init - (only for contract creations) unlimited size byte array specifying the EVM-code for the account initialization procedure - Ti
-data - (only message call) an unlimited size byte array specifying the input data of the message call - Td


function toHex(str) {
 var hex = ''
 for(var i=0;i&lt;str.length;i++) {
  hex += ''+str.charCodeAt(i).toString(16)
 }
 return hex
}

let addr = web3.eth.accounts[0]
let msg = 'I really did make this message'
let signature = web3.eth.sign(addr, '0x' + toHex(msg))
signature = signature.substr(2); //remove 0x
const r = '0x' + signature.slice(0, 64)
const s = '0x' + signature.slice(64, 128)
const v = '0x' + signature.slice(128, 130)
const v_decimal = web3.toDecimal(v)


The block
The block is the collection of relevant pieces of information (block header - H) together with information corresponding to the comprised transactions (T) and a set of other block headers (U) that are known to have parent equal to the present blocks parents parent (ommers/uncles)

The block header contains several pieces of information
-parentHash - Keccak 256 bit hash of the parent blocks header - Hp
-ommersHash - Keccak 256 bit hash of the ommers list portion of this block - Ho
-beneficiary - the 160 bit address to which all fess are collected from the successful mining of this block - Hc
-stateRoot - Keccak 256 bit hash of the root node of the state trie, after all transactions are executed and finalizations applied - Hr
-transactionsRoot - Keccak 256 bit hash of the root node of the trie structure populated with each transaction in the transaction list portion of the block - Ht
-receiptsRoot - Keccak 256 bit hash of the root node of the trie structure populated with the receipts of each transaction in the transactions list portion of the block - He
-logsBloom - bloom filter composed of indexable information (logger address and log topics) contained in each log entry form the receipt of each transaction in the transaction list - Hb
-difficulty - scalar value corresponding to the difficulty level of this block. This can be calculated from the previous blocks difficulty level and the timestamp - Hd
-number - scalar value equal to the number of ancestor blocks. The genesis block = 0. - Hi
-gasLimit - scalar value equal to the current limit of gas expenditure per bock - Hl
-gasUsed - scalar value equal to the total gas used in transaction in this block - Hg
-timestamp - scalar value equal to the reasonable output of unix time() at blocks inception - Hs
-extraData - arbitrary byte array containing data relevant to this block.  Must be 32 bytes or fewer - Hx
-mixHash - 256 bit hash which, combined with nonce, proves that a sufficient amount of computation has be carried out on this block - Hm
-none - 64 bit value which, combined with the mixhash, proves that a sufficient amount of computation has been carried out on this block - Hn
-list of ommer block headers - Bu
-list of transaction - BsubT


Transaction Receipt
Each receipt (BsubR[i] for the ith transaction) is placed in an index-keyed trie and the root recroded in the header (as He)

The receipt (R) is a tuple of 4 items.
Consisting of
-cumulative gas used in the block containing the transaction receipt as of immediately after the transaction has happened - Ru
-the set of logs created through execution of the transaction - Rl
-bloom filter composed from information in these logs - Rb
-status code of the transaction - Rz


Gas and payment
In order to avoid issues of network abuse and sidestep the inevitable questions stemming from Turing completeness (the halting problem), all programmable computation in Ethereum is subject to fees.  The fee schedule is specified in units of gas. Thus any given fragment of programmable computation (creating contracts, making message calls, utilising and accessinga ccount storage, executing operations on the EVM) has a universally agreed cost in terms of gas.
Every transaction has a gasLimit - amount of gas which is implicitly purchased from the senders account balance, at the gasPrice as defined in that transaction. Any unused gas after transaction completes is returned.
Ether used as gas is given to the beneficiary (miner). Senders can set any gasPrice they wish, but miners are free to only include transactions with a high gasPrice.


Transaction Execution
Execution of transaction is most complex part of the Ethereum protocol.  It defines the state transition (Υ).
A transaction must meet the following criteria
1) transaction is well formed RLP, with no additional trailing bytes
2) transaction signature is valid
3) transaction nonce is valid (equivalent to the sender accounts current nonce)
4) gas limit is no smaller than the intrinsic gas used by the transaction
5) sender account balance contains at least the cost required in up front payment

Substate
Throughout transaction execution, we accrue certain information that is acted upon immediately following the transaction.
Consists of:
-self destruct set - set of accounts that will be discarded following the transaction - As
-log series - this is a series of archived and indexable ‘checkpoints’ in VM code execution that allow for contract-calls to be easily tracked (Al)
-set of touched accounts - empty ones are deleted at the end of the transaction - At
-refund balance  - Ar

Execution
The execution of a valid transaction beings with irrevocable change made to the state:
-nonce of the account sender is incremented by 1 
-balance is reduced by up front cost
-Then message call or the contract creation is perfromed
-refund counter has to be incremented for the accounts that were self-destructed

To finalize:
-refundable amount + some allowance from the refund counter
-Ether for gas given to miner
-delete all self-destruct accounts + all touched but empty accounts
-specify total gas used in transaction
-specify logs created by this transaction
-specify status code of this transaction


Contract Creation
There are a number of intrinsic parameters used when creating an account
-sender - s
-original transactor - o
-available gas - g
-gas price - p
-endowment - v
-arbitrary length byte array, initialization EVM code - i
-present depth of the message-call/contract creation stack - e
-permission to make modifications to the state - w

The address of the new account is defined as being the rightmost 160 bits of the Keccak hash of the RLP encoding of the structure containing only the sender and account nonce

The account nonce is set to 1
Balance set as the value passed in
The storage as empty
Code hash as the keccak 256 bit hash of empty string
Senders balance is also reduced by the value passed
Account is initialized through the execution of the initializing EVM code (i) 


Message Call
In the case of executing a message call, several parameters are required
-sender - s
-transaction originator - o
-recipient - r
-account whose code is to be executed - c (usually same as recipient)
-available gas - g
-value - v
-gas price - p
-input data of the call, an arbitrary length byte array - d
-present depth of the message-call/contract creation stack - e
-permission to make modifications to the state - w

Additionally, there is an out put byte array - o


Execution Model
Specifies how the system state is altered given bytecode instructions and small tuple of environmental data.
Technically quasi-Turing complete since gas can limit programs from running forever (halting problem)

EVM is simple stack-based architecture
Word size of the machine (and stack items) is 256 bit
Memory model is simple word-addressed byte array, stack has max of 1024
Independent storage model - word addressable word array - non volatile - maintained as part of system state

Program code is stored in virtual Read only memory (ROM) that can only be accessed by special instructions

Exceptions include stack underflow, invalid instruction, out of gas - all do not leave state changes intact.  Machine halts immediately and reports issue to execution agent.

Fees
Fees are charged under 3 distinct circumstances:
-fee is intrinsic to the computation of the operation
-gas may be deducted in order to form the payment to a subordinate message call or contract creation
-may be paid due to increase in usage of memory

Total fee for memory usage payable is proportional to smallest multiple of 32 bytes that are required such that all memory indices are included in the range.  This is JIT payment - referencing a memory address greater than 32 bytes of previously indexed memory will incur additional memory usage free.  Freed memory is refunded up front and execution fee waived, due to how expensive storage is considered.

Execution Environment
In addition to system state (σ) and remaining gas (g), the following are needed:
-address of the account which owns the code executing - Ia
-sender address of the transaction that originated execution - Io
-price of gas in the transaction that originated this execution - Ip
-byte array that is input data to this execution - if execution agent is transaction, this would be transaction data - Id
-address of the account which caused code to be executing - if the execution agent is a transaction, this would be the transaction sender - Is
-value passed into this account as part of the same procedure as execution - if execution agent is transaction this would be the transaction value - Iv
-byte array that is machine code to be executed - Ib
-the block header of the present block - IsubH
-depth of present message-call or contract-creation - Ie
-permission to make modifications to the state - Iw


Blocktree to blockchain
The canonical blockchain is a path from root to leaf throughout the entire block tree.  To have consensus over which path is is, we identify the path that has had the most computation done upon it (the heaviest path).
The heaviest path is the block number of the leaf, equivalent to the number of blocks (not counting the unmined genesis block).  The longer the path, the great total mining effort.
Since the block header includes the difficulty, the header alone is enough to validate the computation done.


Block Finalization
Process of finalizing:
1-validate ommers/uncles (if mining, determine ommers/uncles)
2-validate transactions (if mining, determine transactions)
3-apply rewards
4-verify state and block nonce (if mining, compute valid state and block nonce)

Ommer validation
Verify each ommer header is both valid header and satisfies the relation of Nth generation ommer to the present block is less than or equal to 6

Transaction validation
Given gasUsed must correspond faithfully to the transactions listed - total gas used in block must be equal to the acculated gas used according to the final transaction

Reward Application
Involves raising the balance of beneficiary accounts of the block and each included ommer (and 1/32 of block reward to blocks beneficiary).

State and Nonce validation
Check status code, log, and cumulative gas after each transaction and apply finalization function









</Text>
        </Document>
        <Document ID="89">
            <Title>Contracts</Title>
        </Document>
        <Document ID="90">
            <Title>Emit events</Title>
            <Text>Use ‘emit’ keyword to fire events off to listening JS 

contract Coin {
    //Your smart contract properties...

    // Sample event definition: use 'event' keyword and define the parameters
    event Sent(address from, address to, uint amount);


    function send(address receiver, uint amount) public {
        //Some code for your intended logic...

        //Call the event that will fire at browser (client-side)
        emit Sent(msg.sender, receiver, amount);
    }
}


The line event Sent(address from, address to, uint amount); declares a so-called “event” which is fired in the last line of the function send. User interfaces (as well as server applications of course) can listen for those events being fired on the blockchain without much cost. As soon as it is fired, the listener will also receive the arguments from, to and amount, which makes it easy to track transactions. In order to listen for this event, you would use.
Javascript code that will catch the event and write some message in the browser console:

Coin.Sent().watch({}, '', function(error, result) {
    if (!error) {
        console.log(&quot;Coin transfer: &quot; + result.args.amount +
            &quot; coins were sent from &quot; + result.args.from +
            &quot; to &quot; + result.args.to + &quot;.&quot;);
        console.log(&quot;Balances now:\n&quot; +
            &quot;Sender: &quot; + Coin.balances.call(result.args.from) +
            &quot;Receiver: &quot; + Coin.balances.call(result.args.to));
    }
})
Ref: http://solidity.readthedocs.io/en/develop/introduction-to-smart-contracts.html

</Text>
        </Document>
        <Document ID="91">
            <Title>Introducing blockchain</Title>
            <Text>With the rise of blockchain, there has been a great deal of interest in the technology as well as how to leverage this emerging tech to solve real world, business problems.  For those that are completely unfamiliar with the concept, we can think about blockchain as simply being a highly distributable ledger that tracks a set of keys and their associated values, along with a list of transactions that caused those accounts and value to have changed.  Stated in another way, we are can view a ledger as a snapshot in time of a state (such as a list of bank accounts), transactions are any events that affect that ledger (users depositing/withdrawing/transferring money), and a subsequent snapshot of the ledger.

Many of the current blockchain technologies focus solely on this aspect, contributing the rise of the concept of cryptocurrency.  However, as the general technology continues to mature and evolve, a few providers have decided to generalize the concept of what a distributed ledger is and can accomplish.  One of the most mature and widely known is the Ethereum network (and subsequently their contributions to HyperLedger).  While blockchain is often conflated with cryptocurrency or inextricably tied to the idea of an account ledger, Ethereum strives to be a “generalized technology which all transaction based state machine concepts may be built” [Wood-2018].

What does this really mean? Ultimately, this means Ethereum aims to provide a system that will track state and state changes, in a highly distributed, trustful framework.  Naturally, this can be extended to include a cryptocurrency (and the main Ethereum project does in fact offer its own variation Ether) but more importantly it is focused on allowing for development on top this complex state machine management platform.  To that end, Ethereum (and subsequent HyperLedger contributions) focus largely on smart contracts.  This has, somewhat paradoxically, led to multiple cryptocurrencies being released on the Ethereum platform, as well as hosting a myriad of other novel ideas such as games, loyalty points, supply chain management etc.

Now, we are ready to to delve into Ethereum specifically, and begin to understand its inner workings as well as how to leverage the technology to do some interesting things.  First, however, there is a need to clarify one additional caveat that will inevitably influence both the audience and the leanings of this book.  Most people, when they refer to blockchains, are referring to the publicly accessible systems such as Ethereum public network, Bitcoin network, etc.  For the entirety of this book, we will be referring to and focusing solely on private networks.  Now what does this mean as a a reader?

Public (or permissionless) blockchains are those that anyone can download the entire chain and contribute miners to the process.  

Private (or permissioned) blockchains are just the opposite.  Miners and nodes must use pre-authorized accounts and will normally not be hosted on the public Internet.  Instead they will reside on private networks, such as inside large companies.  With the use Private blockchains, it allows for more efficient use of computational power and more trusted environment. Specifically, it allows for the use of “Proof of Authority” versus the more widely known (and more computationally expensive) “Proof of Work”.  These two proofs will be discussed in some more detail below, but the focus of this book with center on “Proof of Authority” from this point forward.


￼</Text>
        </Document>
        <Document ID="92">
            <Title> Intro to Blockchain &amp; Ethereum</Title>
        </Document>
        <Document ID="93">
            <Title>Introducing Ethereum</Title>
            <Text>We now should view Ethereum as a transaction-based state machine.  Before we get too involved with what transactions and states are, it is worth getting a generic level of understanding around these concepts.

Any Ethereum network will begin with a “Genesis State”.  This is nothing more than how we set up the system to behave before we actually turn the network on, a nearly blank slate that we can begin to alter and build on top of.  It allows us the ability to create some accounts, front load some values into those accounts, as well set some knobs and switches about the network should act.  As we move from state to state, the latest state is known as the “Final State” or “Canonical State”.

In general, a state can consist of a few different things.  It can be an account balance (in the example of using the Ether cryptocurrency), it can be data about the outside world, it can user reputations or reviews.  A state is simply the current snapshot of the digital properties we are trying to track. 

Given we now have this basic concept of a state, how do we move from one state to another?  For example, how does user Bob move 5 Ether to user Alice?  This transition is what we call a transaction.  It represents a valid move from one state to another, while ensuring the transition is not invalid (a transition can be invalid for many of the same reasons that a function may fail in traditional programming: users aren’t real or valid, the amount being deducted exceeds the amount available in an account, etc). 

The combination of these concepts is what forms the idea for a block.  Once we have some number of transactions that have been committed against a given state, we accumulate these potential changes together into what is known as a block (a specific piece of the Ethereum network is responsible for this piece, it is called a Miner and we will cover them more later).  Blocks function as a journal, recording what transactions caused us to move from State N to State N+1.  Given this basic information, for each block, we would be able to rebuild an entire blockchain (we will discuss this more in depth later on when we touch on Lite vs Full nodes).

￼
￼</Text>
        </Document>
        <Document ID="94">
            <Title>Properties</Title>
        </Document>
        <Document ID="95">
            <Title> Parts of Ethereum</Title>
        </Document>
        <Document ID="96">
            <Title>Blocks</Title>
        </Document>
        <Document ID="97">
            <Title>State</Title>
        </Document>
        <Document ID="98">
            <Title>Tramsactions</Title>
        </Document>
        <Document ID="99">
            <Title>Accounts</Title>
            <Text>Accounts are the way that anything interacts with the blockchain.  Unique to Ethereum, there are two types of accounts that be created.  
- Externally owned accounts 
- Contract accounts.

External accounts are owned by end users.  These are the normal accounts that most people will be familiar with, you sign up for one with a tool such as MIST and you are then able to transfer ether on the network. These external accounts are defined by the fact that they will be controlled by a private key that is created with the account and that the account will not have any EVM code associated with them (we will discuss what the EVM and code is a bit later). Externally owned accounts are also the only accounts that are allowed to kick off transactions within the system.  We will cover transactions in detail below, but for now transactions can be viewed simply as any modification or interaction with the block chain.  Therefore, contracts can not trigger themselves based on timers or events from external systems, the must always be called by a valid external account.

Contract accounts do not have an associated private key but does have EVM code stored in the account. While we know that contracts can initiate transactions themselves, it is worth noting here that once called, a contract may be able to call contracts on the callers behalf. Contract-to-contract calls will be covered more in a subsequent section, but it is an important caveat to be aware of.
￼

Accounts are tracked by the blockchain through something called the 'Account State' (we won't dive too deeply into this now, but want to point out at a high level what is tracked). 

There are only 4 properties that are tracked at an account level 
- Nonce
- Balance
- CodeHash
- StorageRoot
￼</Text>
        </Document>
        <Document ID="100">
            <Title>Addresses</Title>
        </Document>
        <Document ID="101">
            <Title>General</Title>
            <Text>Individual nodes and miners are responsible for getting transactions rolled up into blocks to be included on the blockchain.  This method by which this happens is called consensus. 

There are two main issues that need to be addressed when we talk about the consensus mechanism.

First, how do the members needed for consensus trust new submissions?  There is little to no concern that a node may be intentionally feeding the system bad information. 

The three most popular inclusion mechanisms are:
- Proof of Work
- Proof of Stake
- Proof of Authority

Once we understand how new data can be introduced into the system, next is an issue that plagues many distributed system, how to get trusted nodes to agree to an updated state of the system and ensuring the information being shared is the most up-to-date data. Each blockchain implementation has a way to mitigate this issue, and the method chosen by Ethereum is known as the GHOST protocol. 

</Text>
        </Document>
        <Document ID="102">
            <Title> Contracts</Title>
        </Document>
        <Document ID="103">
            <Title>Transactions</Title>
        </Document>
        <Document ID="104">
            <Title>Ommers-Uncles</Title>
        </Document>
        <Document ID="105">
            <Title>Public VS Private</Title>
        </Document>
        <Document ID="106">
            <Title>misc_pubVSprivate</Title>
        </Document>
        <Document ID="107">
            <Title>General</Title>
            <Text>To better understand the Ethereum platform, we need to delve into the individual parts. 

These parts can be split into two different categories:
-Physical architecture
-Digital representation of the state machine

Since we already know the basic building blocks that constitute the state machine, let’s first look at the physical architecture of the network.  

These will consist of:
- Nodes
- Miners
- Ethereum Virtual Machine (EVM)

Afterward, we will examine the indivdual pieces of the state machine, which include:
- Block
- State
- Transaction
- Accounts
- Addresses
- Consensus
- Ommers/Uncles

</Text>
        </Document>
        <Document ID="108">
            <Title>General</Title>
            <Text>The overall architecture of any Ethereum network can be summarized below.

We have some framework that will sit outside of Ethereum that allows us to easily interact with blockchain, in this case we are showcasing the Web3J javascript framework.

The Ethereum network itself is primarily comprised on only Nodes and Miners.  There can be additions made to the network to extend storage or enhance network communication, but we will only focus on this minimal network deployment.

￼</Text>
        </Document>
        <Document ID="109">
            <Title>Proof of Work</Title>
            <Text>As we know, transactions are constantly flowing into the systems and miners gather some of the transactions together to form a block.  The method by which the block can be 'sealed' and added to the chain differs based on how your blockchain is configured.  Each of the methods below have some inherent flaws, and should be researched in greater detail before choosing one for use within the business.

'Proof of Work' (PoW) is the original consensus algorithm used in blockchains.  It requires miners that are attempting to seal a block to solve complex mathematical problems (often of increasing difficulty). Solving these mathematical (often cryptographic problems) will eventually take excessive computational power, this has been seen in the Bitcoin ecosystem with the progression from CPUs to FPGAs to GPUs and eventually farms. This increased time and complexity does pose a problem for both public and private networks.  In the public realm, it relies on the public at large to front these very expensive systems in hopes of getting a reward for the solution. For private networks, the burden is worse since all actors within the system are trusted, there is no need for them to waste resources and retrieve a trivial reward.

The types of mathematical problems can be any of the following:
- Attempting to determine the input of a hash function given its output.
- Integer factorization where, given a final answer, a miner will attempt to guess 2 numbers that can be multiplied together to achieve the given final answer.
- In extreme cases, a miner may be required to solve multiple of these problems, for several previously solved, but unknown, blocks in a specific order.  This solution is usually only leveraged in situations where the blockchain is under attack by bad actors'

￼</Text>
        </Document>
        <Document ID="110">
            <Title>Proof of Authority</Title>
        </Document>
        <Document ID="111">
            <Title>Proof of Stake</Title>
            <Text>This method arose to offset the high computational cost issues faced with PoW.  With this algorithm, a miner is only allowed to sign blocks based on the amount of currency they own in the system.  Effectively, if a miner has only 3% of the total currency in the system, they will only be able to sign approximately 3% of the blocks in the network. As opposed to a normal system, where miners are actively gathering transactions to build a block, in PoS a miner is assigned by the system at large, based on the stake in the system.  No rewards are granted, since every miner is guaranteed/required to do some work in the system.

￼</Text>
        </Document>
        <Document ID="112"/>
        <Document ID="113">
            <Title>misc_POW</Title>
        </Document>
        <Document ID="114">
            <Title>General</Title>
        </Document>
        <Document ID="115">
            <Title>Nodes and Miners</Title>
        </Document>
        <Document ID="116">
            <Title>misc_POW</Title>
        </Document>
        <Document ID="117">
            <Title>misc_POWvsPOS</Title>
        </Document>
        <Document ID="118">
            <Title>Proof of Authority</Title>
            <Text>Ethereum originally postulated this method of block signing. With this strategy, any miner connected to the system is a known and trusted actor, and therefor able and trusted to seal any block in the system. 

The major caveat with this is, only miners and users that are known can be allowed to connect to the network.  Any outside or 'bad actor' can easily manipulate the system and include fraudulent transactions.

￼</Text>
        </Document>
        <Document ID="119">
            <Title>misc_POA</Title>
        </Document>
        <Document ID="120">
            <Title>GHOST protocol</Title>
            <Text>The way in which Ethereum provides consensus leads to the possibility of two problems.

The first is the way in which nodes will eventually agree on what blockchain is the true chain.  As blocks are added on competing nodes, these new chains are socialized out to neighboring nodes.  What happens when neighboring nodes get differing versions of the same chain?  Each blockchain has its own strategy, Ethereum uses an algorithm called Greedy Heaviest Observed Sub-tree (GHOST).  A node, when presented with differing versions of the chain, will pick the version that has the the most nodes and sub-nodes.

This leads to the second problem.  What happens when the network at large chooses one version of a block chain over another? The winning chain will have more blocks to the chain, but that does not mean it will contain all blocks that were ultimately mined.  In fact, there is a guarantee that during this choosing process, there will be some blocks that have 'accepted' by the network but are not officially a part of the blockchain. These abandoned blocks are known as 'Uncles'

For example, if a consumer purchases an item for $5 using a crypto-currency built on top of Ethereum, the seller waits to verify the transaction gets included into a block, then gives the consumer their product.  However, unknown to the buyer or consumer, the block isn't actually added to the canonical chain.  This means the consumer hasn't had funds removed, the seller hasn't been paid, but the consumer now has their product and has moved on.

Ethereum has a built in resolution for this phenomenon.  When a miners version of the blockchain is not chosen for promotion, blocks that are abandoned are marked as 'Uncles' and tracked.  The network as a whole then offers incentives to miners to pick these Uncle blocks up and include them on future submissions of the blockchain.  Thee incentives, in Proof of Work (PoW), are less than granted for normal transaction mining/block sealing, but are essentially free operation.  The calculations for the block have already been completed, the block hashes just need to be verified and included in the new submission.

Let’s look an example of this.  Any time two blocks are introduced at the same time to two different sets of nodes in the system, we call this a ‘fork’.  Essentially the chain has forked and we have to contend with two different versions existing at the same time.  Since this means Branch A could have our $5 purchase but Branch B doesn’t, we are left with the inevitable conclusion that we have two different account balances.

￼


Recall from early on in our discussion, we know our blockchain begins from a Genesis block (green) and the final, accepted version of the chain is called the Canonical version.  The figure below is updated to reflect this terminology.
￼

But how did we ultimately decide on which was the Canonical version? The GHOST protocol.  Ethereum will continually choose the longest (heaviest) version of the chain and will mark it as the canonical version.  This doesn’t mean that the other forked nodes are lost and, in fact, these forks could become the canonical version themselves in the future.
  ￼
</Text>
        </Document>
        <Document ID="121">
            <Title>misc_ghost</Title>
        </Document>
        <Document ID="122">
            <Title>misc_networkDwg</Title>
        </Document>
        <Document ID="123">
            <Title>Ethereum Virtual Machine (EVM)</Title>
        </Document>
        <Document ID="124">
            <Title>misc_accounts</Title>
        </Document>
        <Document ID="125">
            <Title>misc_accountProperties</Title>
        </Document>
        <Document ID="126">
            <Title>Version 2 - ?? 20??</Title>
            <Synopsis>- revisions of the draft based on second-readings, feedback from your teacher or other reviewers</Synopsis>
            <Text>A
</Text>
        </Document>
        <Document ID="127">
            <Title>Setting up your own private Ethereum network</Title>
        </Document>
        <Document ID="128">
            <Title>References</Title>
        </Document>
        <Document ID="129">
            <Title>Overview of project</Title>
            <Text>The first part of this book was focused on how a blockchain, or Ethereum in particular, works behind the scenes.  It does not get delve too deeply into the advanced concepts of the blockchain, but should paint a very clear picture of transactions flow through and how to interact with it on a conceptual level.  

The second part of this book is dedicated to setting up a new, private, Ethereum network and a dedicated developers machine to interact with it.  While this implementation section can be read without having read the previous section, it is recommended to have a fundamental understanding of its inner workings.  If not, the node setup, the configurations, and the integrations using the remote console will be incredibly confusing and will most likely result in errors.

In this section, we will be setting up two different environments.

The first environment is the private Ethereum network.  This network will consist of a boot node, a normal node, some miners, some swarm nodes, and a couple machines dedicated to monitoring.  These are all defined as docker containers and orchestrated via Docker Compose.  They will be spun in with ‘docker compose up’ with the appropriate ports exposed to allow connecting to the nodes and visualization sites.  It is intended for this to be an entirely self contained network that does not required outside intervention, so once the nodes are up and running, it will be highly reliable test network.

The second environment will be VM that is equipped with all the tooling and resources necessary to get up and running quickly with smart contract development.  It will also contain tools for remotely connecting to the Ethereum network running in Docker.

For this second section, all examples will be shown from a Ubuntu 18 machine and will assume that needed tools have not yet been installed.  Ideally, a reader will be able to go from a bare bones Ubuntu installation to a fully functional example by the end of this section. Mac is also an acceptable OS to try all of this on (and many of the scripts supplied will have a Linux and Mac version).  However, Windows will not work.  Due to incompatibility between Docker, HyperV, VirtualBox, and Vagrant it isn’t possible to run these systems on Windows machines.</Text>
        </Document>
        <Document ID="130">
            <Title>Resources Needed</Title>
            <Text>Before any work can begin, there are several tools that need to be installed and the git repository needs to be cloned locally. 

First, we need to get our system updated and install the git command line

sudo apt-get update
sudo apt-get upgrade
sudo apt-get install git-core

Next, let’s get all the necessary files from github.

@GITREPO

Download the code from the above into a convenient location

cd ~
git clone @GITREPO
cd test-kitchen/ethereum_POC/

Now, we can begin to install the remaining tools that are needed to run the containers and virtual machines.  To make it easier, all of the tools and setup that needs to be done are all contained in a single script file that can be run.

sudo ./Linuxsetup.sh

This command should install the following tools:
virtualbox 
docker.io 
docker-compose 
unzip 
curl 
vagrant

</Text>
        </Document>
        <Document ID="131">
            <Title>Explore</Title>
            <Text>A set of Docker images to create a local Ethereum network with three nodes and a monitor. This was built to understand how local Ethereum networks have to be set up and to provide a local test environment. Never use this in a productive environment, as the docker-compose.yml contains hardcoded passwords and private keys for convenience

The testnet consists out of multiple parts :

1 Bootnode - registers existing nodes on the network, discovery service.
2 Miners - Also called sealers with proof-of-authority. They validate the blocks. No RPC is exposed as they are required to be unlocked.
1 Node - This serves as transaction relay and is a fullnode that does not mine, is locked but has RPC exposed
2 Swarm nodes - These nodes make up the peer-to-peer CDN
1 Blockchain explorer - Lightweight web application to explore the blockchain through web application.
Miners/Nodes have to be initialized with a 'Genesis Block' (the first block of the chain). This is defined in 'genesis.json'


Genesis Section
Description
config{}
configuration settings for the chain stack itself
config.chainId
Required to differentiate different chains (ETH uses id=1, ETC uses id=6, others are listed here )
config.homesteadBlock
Forces use of Homestead release
config.eip150block
Forces use of EIP150 on block #0
https://github.com/ethereum/eips/issues/150
config.eip150hash
Hash needed for fast sync
config.eip155block
Forces use of EIP155 on block #0
https://github.com/ethereum/eips/issues/155
config.eip158block
Forces use of EIP158 on block #0
https://github.com/ethereum/eips/issues/158
config.byzantiumBlock
Forces use of byzantium on block #0
config.clique{}
Forces use of Clique PoA (proof of Authority)
config.clique.period
How long to create new blocks (in sec)
config.clique.epoch
Epoch in blocks (default/recommended is 30000)


nonce
Used (with mixHash) to verify mined block (best to leave at 0)
timestamp
Unix time() output used for first block (value is trivial)
extraData
Required for PoA - must embed initial signer address
gasLimit
Max amount of gas used per block (not transaction) (most examples have this set to 0x8000000)
difficulty
How difficult it is to, statistically, to 'mine' a block (0-10000 is common for private networks, public network is &gt;7million)
mixHash
Used (with nonce) to verify mined block for PoW (may not be used with PoA) (many examples have this at 0)
number
First block number (standard/default is 0)
gasUsed
Gas required to mine the genesis block
parentHash
Hash of the Genesis block (value shouldn't matter - many examples have at 0)


alloc{}
Pre-allocate some accounts with Ethereum coins
alloc.a59…
Give account a59… 'balance' # of coins

 
More can be found about the following:

Byzantium - https://medium.com/digitalassetresearch/understanding-byzantium-what-it-represents-to-the-ethereum-network-9de3d00d552a
Chain Id - https://ethereum.stackexchange.com/questions/17051/how-to-select-a-network-id-or-is-there-a-list-of-network-ids
Clique PoA - https://medium.com/coinmonks/ethereum-clique-poa-vs-pow-11be52cddde1
https://github.com/ethereum/EIPs/issues/225

The bootnode
[~/test-kitchen/ethereum_poc/geth-dev/bootnode]
The nodes in the network are connecting with the bootnode. This is a special ethereum node, designed to provide a register of the existing nodes in the network. The parameter nodekeyhexin the docker-compose.yml is needed to derive the enodeID which is later passed to the other nodes. The IP needs to be fixed, as the other nodes need to know where to find the bootnode, and DNS is not supported. The bootnode does not participate in synchronization of state or mining.

Miners
[~/test-kitchen/ethereum_poc/geth-dev/miner]
There are three nodes that participate in the network. The state is synchronized between them and they are trying to create blocks with mining. Initially they connect to the bootnode with the information derived from the fixed IP and the nodekeyhex. If you want to interact with the network, you need to connect via RPC. You can attach a geth instance, connect Remix IDE or connect your browser with web3 and build a ÐApp.

The RPC Ports of the nodes are mapped to your localhost, the addresses are:

geth-dev-miner-1 : (only exposed for network stat site)http://localhost:8547
geth-dev-miner-2: (only exposed for network stat site)http://localhost:8546 

Node
[~/test-kitchen/ethereum_poc/geth-dev/miner]
There are three nodes that participate in the network. The state is synchronized between them and they are trying to create blocks with mining. Initially they connect to the bootnode with the information derived from the fixed IP and the nodekeyhex. If you want to interact with the network, you need to connect via RPC. You can attach a geth instance, connect Remix IDE or connect your browser with web3 and build a ÐApp.

The RPC Ports of the nodes are mapped to your localhost, the addresses are: 

geth-dev-node: (used for geth attach)http://localhost:8545


Swarm (/BZZ:/)
[~/test-kitchen/ethereum_poc/geth-dev/swarm]
Swarm is a distributed storage platform and content distribution service, a native base layer service of the ethereum web3 stack. The primary objective of Swarm is to provide a sufficiently decentralized and redundant store of Ethereum’s public record, in particular to store and distribute dapp code and data as well as blockchain data. From an economic point of view, it allows participants to efficiently pool their storage and bandwidth resources in order to provide these services to all participants of the network, all while being incentivised by Ethereum. Files on Swarm are represented by their KECCAK256 Checksum.

The RPC Ports of the nodes are mapped to your localhost, the addresses are:

http://localhost:8500 - geth-swarm-1
http://localhost:8501 - geth-swarm-2


Blockchain Explorer
[~/test-kitchen/ethereum_poc/geth-dev/explorer]
The blockchain explorer is a simple node.js web application being provided by a seperate container: geth-explorer. The application uses the web3 javascript API to fetch the data from geth-dev-node through RPC calls. The blockchain explorer can be found at http://localhost:8080.


Network Monitor
[~/test-kitchen/ethereum_poc/geth-dev/monitor-backend]
[~/test-kitchen/ethereum_poc/geth-dev/monitor-frontend]
This is a visual interface for tracking ethereum network status. It uses WebSockets to receive stats from running nodes and output them through an angular interface. It is the front-end implementation for eth-net-intelligence-api.

https://medium.com/coinmonks/how-to-build-ethereum-dashboard-and-to-monitor-your-ethereum-network-status-9f1941beac08

google-chrome http://localhost:3000/</Text>
        </Document>
        <Document ID="132">
            <Title>Developer Machine</Title>
        </Document>
        <Document ID="133">
            <Title>Ethereum network</Title>
        </Document>
        <Document ID="134">
            <Title>Explore</Title>
            <Text>this machine is defined in vagrant and will have the following toolsets for developing/testing on ethereum

truffle
A world class development environment, testing framework and asset pipeline for blockchains using the Ethereum Virtual Machine (EVM), aiming to make life as a developer easier.
https://www.trufflesuite.com/truffle
https://github.com/trufflesuite/truffle
https://www.trufflesuite.com/docs/truffle/overview

ganache
A personal blockchain for Ethereum development you can use to deploy contracts, develop your applications, and run tests. It is available as both a desktop application as well as a command-line tool (formerly known as the TestRPC). Ganache is available for Windows, Mac, and Linux.
https://www.trufflesuite.com/ganache
https://github.com/trufflesuite/ganache
https://www.trufflesuite.com/docs/ganache/overview

geth
geth is the the command line interface for running a full ethereum node implemented in Go.
https://github.com/ethereum/go-ethereum/wiki/geth

solc
Solidity is an object-oriented, high-level language for implementing smart contracts. Smart contracts are programs which govern the behaviour of accounts within the Ethereum state.
SOLC is the compiler for Solidity based contracts
https://solidity.readthedocs.io/en/v0.5.10/</Text>
        </Document>
        <Document ID="135">
            <Title>EthereumBlockchain_v1</Title>
        </Document>
        <Document ID="136">
            <Title>Physical Architecture</Title>
        </Document>
        <Document ID="137">
            <Title>State Machine</Title>
        </Document>
        <Document ID="138">
            <Title>Consensus Mechanism</Title>
        </Document>
        <Document ID="139">
            <Title>General info</Title>
            <Text>General info 

https://medium.com/@preethikasireddy/how-does-ethereum-work-anyway-22d1df506369
https://medium.com/fitchain/this-is-how-ethereum-works-60f37abd5ef5
https://medium.com/blockchannel/life-cycle-of-an-ethereum-transaction-e5c66bae0f6e
https://www.lsenta.io/posts/storage-and-dapps-on-ethereum-blockchain/
https://hackernoon.com/getting-deep-into-ethereum-how-data-is-stored-in-ethereum-e3f669d96033
https://hackernoon.com/getting-deep-into-evm-how-ethereum-works-backstage-ac7efa1f0015
https://hackernoon.com/5-resources-to-get-started-with-ethereum-4fbf1b5aa57a

loyalty demo (/loyalty)

https://github.com/Rishabh42/Ethereum-customer-loyalty-program/tree/master/server/ethereum/contracts

supply chain (/supplyChain)

https://github.com/imperialsoftech/coffee-supplychain-ethereum
https://github.com/daitan-innovation/ethereum-supply-chain
https://www.freecodecamp.org/news/how-to-build-a-car-manufacturing-supply-chain-system-using-ethereum-cbb87144cde5/

developer machine (/developerMachine)

1 truffle
https://www.trufflesuite.com/truffle
https://github.com/trufflesuite/truffle
https://www.trufflesuite.com/docs/truffle/overview

2 ganache
https://www.trufflesuite.com/ganache
https://github.com/trufflesuite/ganache
https://www.trufflesuite.com/docs/ganache/overview

3 geth
https://github.com/ethereum/go-ethereum/wiki/geth

4 solc
https://solidity.readthedocs.io/en/v0.5.10/


http://demystifyblockchain.com/2018/06/29/getting-started-with-ethereum-blockchain-development-part-1/
http://demystifyblockchain.com/2018/06/29/getting-started-with-ethereum-blockchain-development/
http://demystifyblockchain.com/2018/06/29/what-the-hack-is-memory-and-storage-in-solidity/
https://github.com/ethereum/go-ethereum/wiki/Installation-Instructions-for-Ubuntu
http://www.dappuniversity.com/articles/the-ultimate-ethereum-dapp-tutorial
https://medium.com/blockchainbistro/set-up-a-private-ethereum-blockchain-and-deploy-your-first-solidity-smart-contract-on-the-caa8334c343d</Text>
        </Document>
        <Document ID="140">
            <Title>Install</Title>
        </Document>
        <Document ID="141">
            <Title>Install</Title>
            <Text>Bootstrapping the network only requires starting the docker compose file.  Before we dive into the details of what is involved, let’s run the commands needed to get it started.  The network should start and synchronize without any further configuration. The networks always uses the latest available versions of Ethereum and Swarm, the network is set up for clique proof-of-authority similar to the Ethereum Rinkeby testnet.

cd ~/test-kitchen/ethereum_poc/geth-dev
docker compose up

The terminal window will be occupied with the docker containers and will constantly stream out information as the nodes continue to work.

</Text>
        </Document>
    </Documents>
</SearchIndexes>
